# *** THIS FILE IS AUTOMATICALLY GENERATED ***

const _pyabstractcomplextype = pynull()
unsafe_pyabstractcomplextype() = unsafe_cacheget!(_pyabstractcomplextype) do; unsafe_pyimportattr("numbers", "Complex"); end
pyabstractcomplextype(args...; kwargs...) = safe(unsafe_pyabstractcomplextype(args...; kwargs...))
export pyabstractcomplextype


const _pyabstractrationaltype = pynull()
unsafe_pyabstractrationaltype() = unsafe_cacheget!(_pyabstractrationaltype) do; unsafe_pyimportattr("numbers", "Rational"); end
pyabstractrationaltype(args...; kwargs...) = safe(unsafe_pyabstractrationaltype(args...; kwargs...))
export pyabstractrationaltype


const _pytimedeltatype = pynull()
unsafe_pytimedeltatype() = unsafe_cacheget!(_pytimedeltatype) do; unsafe_pyimportattr("datetime", "timedelta"); end
pytimedeltatype(args...; kwargs...) = safe(unsafe_pytimedeltatype(args...; kwargs...))
export pytimedeltatype


pyerror_occurred_LookupError() = pyerror_occurred(pyexc_LookupError_type())
pyerror_occurred_LookupError(args...; kwargs...) = safe(unsafe_pyerror_occurred_LookupError(args...; kwargs...))
export pyerror_occurred_LookupError


pyerror_occurred_BufferError() = pyerror_occurred(pyexc_BufferError_type())
pyerror_occurred_BufferError(args...; kwargs...) = safe(unsafe_pyerror_occurred_BufferError(args...; kwargs...))
export pyerror_occurred_BufferError


pyerror_occurred_Exception() = pyerror_occurred(pyexc_Exception_type())
pyerror_occurred_Exception(args...; kwargs...) = safe(unsafe_pyerror_occurred_Exception(args...; kwargs...))
export pyerror_occurred_Exception


function unsafe_pytuple_setitem(x1::Any, x2::Any, x3::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x3, AbstractPyRef)
        x3 = unsafe_pyobj(x3)
        isnull(x3) && return ValueOrError{Nothing}()
    end

    incref!(x3)
    r = ccall((:PyTuple_SetItem, PYLIB), Cint, (Ptr{Cvoid}, CPy_ssize_t, Ptr{Cvoid}), x1, x2, x3)
    if r == -1
        decref!(x3)
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end


const _pytextiowrappertype = pynull()
unsafe_pytextiowrappertype() = unsafe_cacheget!(_pytextiowrappertype) do; unsafe_pyimportattr("io", "TextIOWrapper"); end
pytextiowrappertype(args...; kwargs...) = safe(unsafe_pytextiowrappertype(args...; kwargs...))
export pytextiowrappertype


const _pyexc_SystemExit_type = pynull()
unsafe_pyexc_SystemExit_type() = unsafe_cacheget!(_pyexc_SystemExit_type) do; unsafe_load(cglobal((:PyExc_SystemExit, PYLIB), PyPtr)); end
pyexc_SystemExit_type(args...; kwargs...) = safe(unsafe_pyexc_SystemExit_type(args...; kwargs...))
export pyexc_SystemExit_type


const _pyfalse = pynull()
unsafe_pyfalse() = unsafe_cacheget!(_pyfalse) do; cglobal((:_Py_FalseStruct, PYLIB), CPyObject); end
pyfalse(args...; kwargs...) = safe(unsafe_pyfalse(args...; kwargs...))
export pyfalse


pyerror_occurred_SyntaxError() = pyerror_occurred(pyexc_SyntaxError_type())
pyerror_occurred_SyntaxError(args...; kwargs...) = safe(unsafe_pyerror_occurred_SyntaxError(args...; kwargs...))
export pyerror_occurred_SyntaxError


const _pyexc_AssertionError_type = pynull()
unsafe_pyexc_AssertionError_type() = unsafe_cacheget!(_pyexc_AssertionError_type) do; unsafe_load(cglobal((:PyExc_AssertionError, PYLIB), PyPtr)); end
pyexc_AssertionError_type(args...; kwargs...) = safe(unsafe_pyexc_AssertionError_type(args...; kwargs...))
export pyexc_AssertionError_type


unsafe_pyeval(args...; kwargs...) = unsafe_pycall_args(pyevalfunction(), args, kwargs)
pyeval(args...; kwargs...) = safe(unsafe_pyeval(args...; kwargs...))
export pyeval


pyerror_set_KeyError() = pyerror_set(pyexc_KeyError_type())
pyerror_set_KeyError(arg) = pyerror_set(pyexc_KeyError_type(), arg)
pyerror_set_KeyError(args...; kwargs...) = safe(unsafe_pyerror_set_KeyError(args...; kwargs...))
export pyerror_set_KeyError


const _pytzinfotype = pynull()
unsafe_pytzinfotype() = unsafe_cacheget!(_pytzinfotype) do; unsafe_pyimportattr("datetime", "tzinfo"); end
pytzinfotype(args...; kwargs...) = safe(unsafe_pytzinfotype(args...; kwargs...))
export pytzinfotype


pyerror_set_LookupError() = pyerror_set(pyexc_LookupError_type())
pyerror_set_LookupError(arg) = pyerror_set(pyexc_LookupError_type(), arg)
pyerror_set_LookupError(args...; kwargs...) = safe(unsafe_pyerror_set_LookupError(args...; kwargs...))
export pyerror_set_LookupError


unsafe_pytimedelta(args...; kwargs...) = unsafe_pycall_args(pytimedeltatype(), args, kwargs)
pytimedelta(args...; kwargs...) = safe(unsafe_pytimedelta(args...; kwargs...))
export pytimedelta


unsafe_pyisabstractbufferedio(o) = unsafe_pyisinstance(o, pyabstractbufferediotype())
pyisabstractbufferedio(args...; kwargs...) = safe(unsafe_pyisabstractbufferedio(args...; kwargs...))
export pyisabstractbufferedio


pyisslice(o) = unsafe_pytype_check(o, pyslicetype())
pyisslice(args...; kwargs...) = safe(unsafe_pyisslice(args...; kwargs...))
export pyisslice


unsafe_pyrange(args...; kwargs...) = unsafe_pycall_args(pyrangetype(), args, kwargs)
pyrange(args...; kwargs...) = safe(unsafe_pyrange(args...; kwargs...))
export pyrange


function unsafe_pyilshift(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceLshift, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyilshift(args...; kwargs...) = safe(unsafe_pyilshift(args...; kwargs...))
export pyilshift


pyerror_set_ValueError() = pyerror_set(pyexc_ValueError_type())
pyerror_set_ValueError(arg) = pyerror_set(pyexc_ValueError_type(), arg)
pyerror_set_ValueError(args...; kwargs...) = safe(unsafe_pyerror_set_ValueError(args...; kwargs...))
export pyerror_set_ValueError


const _pyexc_RuntimeError_type = pynull()
unsafe_pyexc_RuntimeError_type() = unsafe_cacheget!(_pyexc_RuntimeError_type) do; unsafe_load(cglobal((:PyExc_RuntimeError, PYLIB), PyPtr)); end
pyexc_RuntimeError_type(args...; kwargs...) = safe(unsafe_pyexc_RuntimeError_type(args...; kwargs...))
export pyexc_RuntimeError_type


pyerror_set_NotImplementedError() = pyerror_set(pyexc_NotImplementedError_type())
pyerror_set_NotImplementedError(arg) = pyerror_set(pyexc_NotImplementedError_type(), arg)
pyerror_set_NotImplementedError(args...; kwargs...) = safe(unsafe_pyerror_set_NotImplementedError(args...; kwargs...))
export pyerror_set_NotImplementedError


pyisfloat(o) = unsafe_pytype_check(o, pyfloattype())
pyisfloat(args...; kwargs...) = safe(unsafe_pyisfloat(args...; kwargs...))
export pyisfloat


function unsafe_pyiabs(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceAbsolute, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyiabs(args...; kwargs...) = safe(unsafe_pyiabs(args...; kwargs...))
export pyiabs


function unsafe_pyirshift(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceRshift, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyirshift(args...; kwargs...) = safe(unsafe_pyirshift(args...; kwargs...))
export pyirshift


pyerror_occurred_AttributeError() = pyerror_occurred(pyexc_AttributeError_type())
pyerror_occurred_AttributeError(args...; kwargs...) = safe(unsafe_pyerror_occurred_AttributeError(args...; kwargs...))
export pyerror_occurred_AttributeError


const _pyexc_KeyError_type = pynull()
unsafe_pyexc_KeyError_type() = unsafe_cacheget!(_pyexc_KeyError_type) do; unsafe_load(cglobal((:PyExc_KeyError, PYLIB), PyPtr)); end
pyexc_KeyError_type(args...; kwargs...) = safe(unsafe_pyexc_KeyError_type(args...; kwargs...))
export pyexc_KeyError_type


pyerror_set_IndentationError() = pyerror_set(pyexc_IndentationError_type())
pyerror_set_IndentationError(arg) = pyerror_set(pyexc_IndentationError_type(), arg)
pyerror_set_IndentationError(args...; kwargs...) = safe(unsafe_pyerror_set_IndentationError(args...; kwargs...))
export pyerror_set_IndentationError


pyerror_occurred_KeyboardInterrupt() = pyerror_occurred(pyexc_KeyboardInterrupt_type())
pyerror_occurred_KeyboardInterrupt(args...; kwargs...) = safe(unsafe_pyerror_occurred_KeyboardInterrupt(args...; kwargs...))
export pyerror_occurred_KeyboardInterrupt


function unsafe_pycompare(x1::Any, x2::Any, x3::CPy_CompareOp)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Bool}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Bool}()
    end

    r = ccall((:PyObject_RichCompareBool, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}, CPy_CompareOp), x1, x2, x3)
    if r == -1
        return ValueOrError{Bool}()
    else
        return ValueOrError{Bool}(r != 0)
    end
end
pycompare(args...; kwargs...) = safe(unsafe_pycompare(args...; kwargs...))
export pycompare


pyerror_occurred_FloatingPointError() = pyerror_occurred(pyexc_FloatingPointError_type())
pyerror_occurred_FloatingPointError(args...; kwargs...) = safe(unsafe_pyerror_occurred_FloatingPointError(args...; kwargs...))
export pyerror_occurred_FloatingPointError


pyerror_set_NameError() = pyerror_set(pyexc_NameError_type())
pyerror_set_NameError(arg) = pyerror_set(pyexc_NameError_type(), arg)
pyerror_set_NameError(args...; kwargs...) = safe(unsafe_pyerror_set_NameError(args...; kwargs...))
export pyerror_set_NameError


function unsafe_pydelattr(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyObject_DelAttr, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end
function unsafe_pydelattr(x1::Any, x2::AbstractString)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyObject_DelAttrString, PYLIB), Cint, (Ptr{Cvoid}, Cstring), x1, x2)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end
pydelattr(args...; kwargs...) = safe(unsafe_pydelattr(args...; kwargs...))
export pydelattr


unsafe_pyisabstractrawio(o) = unsafe_pyisinstance(o, pyabstractrawiotype())
pyisabstractrawio(args...; kwargs...) = safe(unsafe_pyisabstractrawio(args...; kwargs...))
export pyisabstractrawio


function unsafe_pyitruediv(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceTrueDivide, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyitruediv(args...; kwargs...) = safe(unsafe_pyitruediv(args...; kwargs...))
export pyitruediv


unsafe_pyisabstractnumber(o) = unsafe_pyisinstance(o, pyabstractnumbertype())
pyisabstractnumber(args...; kwargs...) = safe(unsafe_pyisabstractnumber(args...; kwargs...))
export pyisabstractnumber


unsafe_pybufferedreaderio(args...; kwargs...) = unsafe_pycall_args(pybufferedreaderiotype(), args, kwargs)
pybufferedreaderio(args...; kwargs...) = safe(unsafe_pybufferedreaderio(args...; kwargs...))
export pybufferedreaderio


function unsafe_pyhasattr(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Bool}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Bool}()
    end

    r = ccall((:PyObject_HasAttr, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == -1
        return ValueOrError{Bool}()
    else
        return ValueOrError{Bool}(r != 0)
    end
end
function unsafe_pyhasattr(x1::Any, x2::AbstractString)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Bool}()
    end

    r = ccall((:PyObject_HasAttrString, PYLIB), Cint, (Ptr{Cvoid}, Cstring), x1, x2)
    if r == -1
        return ValueOrError{Bool}()
    else
        return ValueOrError{Bool}(r != 0)
    end
end
pyhasattr(args...; kwargs...) = safe(unsafe_pyhasattr(args...; kwargs...))
export pyhasattr


function pyerror_clear()
    r = ccall((:PyErr_Clear, PYLIB), Cvoid, (), )
    return r
end


function unsafe_pypow(x1::Any, x2::Any, x3::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    if !isa(x3, AbstractPyRef)
        x3 = unsafe_pyobj(x3)
        isnull(x3) && return PYNULL
    end

    r = ccall((:PyNumber_Power, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), x1, x2, x3)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pypow(args...; kwargs...) = safe(unsafe_pypow(args...; kwargs...))
export pypow


function unsafe_pyimport(x1::AbstractString)
    r = ccall((:PyImport_ImportModule, PYLIB), Ptr{Cvoid}, (Cstring,), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
function unsafe_pyimport(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyImport_Import, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyimport(args...; kwargs...) = safe(unsafe_pyimport(args...; kwargs...))
export pyimport


const _pyevalfunction = pynull()
unsafe_pyevalfunction() = unsafe_cacheget!(_pyevalfunction) do; unsafe_pybuiltin("eval"); end
pyevalfunction(args...; kwargs...) = safe(unsafe_pyevalfunction(args...; kwargs...))


pyerror_set_AssertionError() = pyerror_set(pyexc_AssertionError_type())
pyerror_set_AssertionError(arg) = pyerror_set(pyexc_AssertionError_type(), arg)
pyerror_set_AssertionError(args...; kwargs...) = safe(unsafe_pyerror_set_AssertionError(args...; kwargs...))
export pyerror_set_AssertionError


unsafe_pyisabstractrational(o) = unsafe_pyisinstance(o, pyabstractrationaltype())
pyisabstractrational(args...; kwargs...) = safe(unsafe_pyisabstractrational(args...; kwargs...))
export pyisabstractrational


pyisdict(o) = unsafe_pytype_check_fast(o, CPy_TPFLAGS_DICT_SUBCLASS)
pyisdict(args...; kwargs...) = safe(unsafe_pyisdict(args...; kwargs...))
export pyisdict


const _pynonetype = pynull()
unsafe_pynonetype() = unsafe_cacheget!(_pynonetype) do; unsafe_pytype(unsafe_pynone()); end
pynonetype(args...; kwargs...) = safe(unsafe_pynonetype(args...; kwargs...))
export pynonetype


function unsafe_pystr_asutf8string(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyUnicode_AsUTF8String, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


unsafe_pyfrozenset(args...; kwargs...) = unsafe_pycall_args(pyfrozensettype(), args, kwargs)
pyfrozenset(args...; kwargs...) = safe(unsafe_pyfrozenset(args...; kwargs...))
export pyfrozenset


function unsafe_pyiter_next(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyIter_Next, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if (r == C_NULL) && pyerror_occurred()
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


const _pyexc_ArithmeticError_type = pynull()
unsafe_pyexc_ArithmeticError_type() = unsafe_cacheget!(_pyexc_ArithmeticError_type) do; unsafe_load(cglobal((:PyExc_ArithmeticError, PYLIB), PyPtr)); end
pyexc_ArithmeticError_type(args...; kwargs...) = safe(unsafe_pyexc_ArithmeticError_type(args...; kwargs...))
export pyexc_ArithmeticError_type


pyerror_occurred_ValueError() = pyerror_occurred(pyexc_ValueError_type())
pyerror_occurred_ValueError(args...; kwargs...) = safe(unsafe_pyerror_occurred_ValueError(args...; kwargs...))
export pyerror_occurred_ValueError


function unsafe_pydict_setitem_string(x1::Any, x2::AbstractString, x3::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x3, AbstractPyRef)
        x3 = unsafe_pyobj(x3)
        isnull(x3) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyDict_SetItemString, PYLIB), Cint, (Ptr{Cvoid}, Cstring, Ptr{Cvoid}), x1, x2, x3)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end


pyerror_set_KeyboardInterrupt() = pyerror_set(pyexc_KeyboardInterrupt_type())
pyerror_set_KeyboardInterrupt(arg) = pyerror_set(pyexc_KeyboardInterrupt_type(), arg)
pyerror_set_KeyboardInterrupt(args...; kwargs...) = safe(unsafe_pyerror_set_KeyboardInterrupt(args...; kwargs...))
export pyerror_set_KeyboardInterrupt


function unsafe_pydelitem(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyObject_DelItem, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end
pydelitem(args...; kwargs...) = safe(unsafe_pydelitem(args...; kwargs...))
export pydelitem


function unsafe_pyneg(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_Negative, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyneg(args...; kwargs...) = safe(unsafe_pyneg(args...; kwargs...))
export pyneg


function unsafe_pycomplex_realasdouble(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Cdouble}()
    end

    r = ccall((:PyComplex_RealAsDouble, PYLIB), Cdouble, (Ptr{Cvoid},), x1)
    if iszero(r + one(r)) && pyerror_occurred()
        return ValueOrError{Cdouble}()
    else
        return ValueOrError{Cdouble}(r)
    end
end


function unsafe_pyint_aslonglong(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Clonglong}()
    end

    r = ccall((:PyLong_AsLongLong, PYLIB), Clonglong, (Ptr{Cvoid},), x1)
    if iszero(r + one(r)) && pyerror_occurred()
        return ValueOrError{Clonglong}()
    else
        return ValueOrError{Clonglong}(r)
    end
end


const _pyexc_Exception_type = pynull()
unsafe_pyexc_Exception_type() = unsafe_cacheget!(_pyexc_Exception_type) do; unsafe_load(cglobal((:PyExc_Exception, PYLIB), PyPtr)); end
pyexc_Exception_type(args...; kwargs...) = safe(unsafe_pyexc_Exception_type(args...; kwargs...))
export pyexc_Exception_type


const _pyexc_ValueError_type = pynull()
unsafe_pyexc_ValueError_type() = unsafe_cacheget!(_pyexc_ValueError_type) do; unsafe_load(cglobal((:PyExc_ValueError, PYLIB), PyPtr)); end
pyexc_ValueError_type(args...; kwargs...) = safe(unsafe_pyexc_ValueError_type(args...; kwargs...))
export pyexc_ValueError_type


function unsafe_pyhash(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{CPy_hash_t}()
    end

    r = ccall((:PyObject_Hash, PYLIB), CPy_hash_t, (Ptr{Cvoid},), x1)
    if iszero(r + one(r))
        return ValueOrError{CPy_hash_t}()
    else
        return ValueOrError{CPy_hash_t}(r)
    end
end
pyhash(args...; kwargs...) = safe(unsafe_pyhash(args...; kwargs...))
export pyhash


pyerror_set_TypeError() = pyerror_set(pyexc_TypeError_type())
pyerror_set_TypeError(arg) = pyerror_set(pyexc_TypeError_type(), arg)
pyerror_set_TypeError(args...; kwargs...) = safe(unsafe_pyerror_set_TypeError(args...; kwargs...))
export pyerror_set_TypeError


function unsafe_pyint_fromulonglong(x1::Any)
    r = ccall((:PyLong_FromUnsignedLongLong, PYLIB), Ptr{Cvoid}, (Clonglong,), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


pyerror_occurred_IOUnsupportedOperation() = pyerror_occurred(pyexc_IOUnsupportedOperation_type())
pyerror_occurred_IOUnsupportedOperation(args...; kwargs...) = safe(unsafe_pyerror_occurred_IOUnsupportedOperation(args...; kwargs...))
export pyerror_occurred_IOUnsupportedOperation


function unsafe_pyerror_ptr()
    r = ccall((:PyErr_Occurred, PYLIB), Ptr{Cvoid}, (), )
    return r
end


const _pyexc_BaseException_type = pynull()
unsafe_pyexc_BaseException_type() = unsafe_cacheget!(_pyexc_BaseException_type) do; unsafe_load(cglobal((:PyExc_BaseException, PYLIB), PyPtr)); end
pyexc_BaseException_type(args...; kwargs...) = safe(unsafe_pyexc_BaseException_type(args...; kwargs...))
export pyexc_BaseException_type


function unsafe_pyissubclass(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Bool}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Bool}()
    end

    r = ccall((:PyObject_IsSubclass, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == -1
        return ValueOrError{Bool}()
    else
        return ValueOrError{Bool}(r != 0)
    end
end
pyissubclass(args...; kwargs...) = safe(unsafe_pyissubclass(args...; kwargs...))
export pyissubclass


pyerror_set_EOFError() = pyerror_set(pyexc_EOFError_type())
pyerror_set_EOFError(arg) = pyerror_set(pyexc_EOFError_type(), arg)
pyerror_set_EOFError(args...; kwargs...) = safe(unsafe_pyerror_set_EOFError(args...; kwargs...))
export pyerror_set_EOFError


const _pytimezonetype = pynull()
unsafe_pytimezonetype() = unsafe_cacheget!(_pytimezonetype) do; unsafe_pyimportattr("datetime", "timezone"); end
pytimezonetype(args...; kwargs...) = safe(unsafe_pytimezonetype(args...; kwargs...))
export pytimezonetype


pyistextiowrapper(o) = unsafe_pytype_check(o, pytextiowrappertype())
pyistextiowrapper(args...; kwargs...) = safe(unsafe_pyistextiowrapper(args...; kwargs...))
export pyistextiowrapper


const _pycomplextype = pynull()
unsafe_pycomplextype() = unsafe_cacheget!(_pycomplextype) do; cglobal((:PyComplex_Type, PYLIB), CPyObject); end
pycomplextype(args...; kwargs...) = safe(unsafe_pycomplextype(args...; kwargs...))
export pycomplextype


pyislist(o) = unsafe_pytype_check_fast(o, CPy_TPFLAGS_LIST_SUBCLASS)
pyislist(args...; kwargs...) = safe(unsafe_pyislist(args...; kwargs...))
export pyislist


function unsafe_pyfloat(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_Float, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
function unsafe_pyfloat(x1::Real)
    r = ccall((:PyFloat_FromDouble, PYLIB), Ptr{Cvoid}, (Cdouble,), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
unsafe_pyfloat(args...; kwargs...) = unsafe_pycall_args(pyfloattype(), args, kwargs)
pyfloat(args...; kwargs...) = safe(unsafe_pyfloat(args...; kwargs...))
export pyfloat


const _pyabstractiotype = pynull()
unsafe_pyabstractiotype() = unsafe_cacheget!(_pyabstractiotype) do; unsafe_pyimportattr("io", "IOBase"); end
pyabstractiotype(args...; kwargs...) = safe(unsafe_pyabstractiotype(args...; kwargs...))
export pyabstractiotype


pyerror_set_IndexError() = pyerror_set(pyexc_IndexError_type())
pyerror_set_IndexError(arg) = pyerror_set(pyexc_IndexError_type(), arg)
pyerror_set_IndexError(args...; kwargs...) = safe(unsafe_pyerror_set_IndexError(args...; kwargs...))
export pyerror_set_IndexError


const _pydatetype = pynull()
unsafe_pydatetype() = unsafe_cacheget!(_pydatetype) do; unsafe_pyimportattr("datetime", "date"); end
pydatetype(args...; kwargs...) = safe(unsafe_pydatetype(args...; kwargs...))
export pydatetype


pyerror_set_SyntaxError() = pyerror_set(pyexc_SyntaxError_type())
pyerror_set_SyntaxError(arg) = pyerror_set(pyexc_SyntaxError_type(), arg)
pyerror_set_SyntaxError(args...; kwargs...) = safe(unsafe_pyerror_set_SyntaxError(args...; kwargs...))
export pyerror_set_SyntaxError


const _pyfractiontype = pynull()
unsafe_pyfractiontype() = unsafe_cacheget!(_pyfractiontype) do; unsafe_pyimportattr("fractions", "Fraction"); end
pyfractiontype(args...; kwargs...) = safe(unsafe_pyfractiontype(args...; kwargs...))
export pyfractiontype


const _pystringiotype = pynull()
unsafe_pystringiotype() = unsafe_cacheget!(_pystringiotype) do; unsafe_pyimportattr("io", "StringIO"); end
pystringiotype(args...; kwargs...) = safe(unsafe_pystringiotype(args...; kwargs...))
export pystringiotype


function unsafe_pyimul(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceMultiply, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyimul(args...; kwargs...) = safe(unsafe_pyimul(args...; kwargs...))
export pyimul


pyerror_occurred_TypeError() = pyerror_occurred(pyexc_TypeError_type())
pyerror_occurred_TypeError(args...; kwargs...) = safe(unsafe_pyerror_occurred_TypeError(args...; kwargs...))
export pyerror_occurred_TypeError


function unsafe_pyimatmul(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceMatrixMultiply, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyimatmul(args...; kwargs...) = safe(unsafe_pyimatmul(args...; kwargs...))
export pyimatmul


function unsafe_pyiadd(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceAdd, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyiadd(args...; kwargs...) = safe(unsafe_pyiadd(args...; kwargs...))
export pyiadd


function unsafe_pylshift(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Lshift, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pylshift(args...; kwargs...) = safe(unsafe_pylshift(args...; kwargs...))
export pylshift


const _pyellipsistype = pynull()
unsafe_pyellipsistype() = unsafe_cacheget!(_pyellipsistype) do; unsafe_pytype(unsafe_pyellipsis()); end
pyellipsistype(args...; kwargs...) = safe(unsafe_pyellipsistype(args...; kwargs...))
export pyellipsistype


unsafe_pysuper(args...; kwargs...) = unsafe_pycall_args(pysupertype(), args, kwargs)
pysuper(args...; kwargs...) = safe(unsafe_pysuper(args...; kwargs...))
export pysuper


const _pybufferedrwiotype = pynull()
unsafe_pybufferedrwiotype() = unsafe_cacheget!(_pybufferedrwiotype) do; unsafe_pyimportattr("io", "BufferedRW"); end
pybufferedrwiotype(args...; kwargs...) = safe(unsafe_pybufferedrwiotype(args...; kwargs...))
export pybufferedrwiotype


const _pyexc_AttributeError_type = pynull()
unsafe_pyexc_AttributeError_type() = unsafe_cacheget!(_pyexc_AttributeError_type) do; unsafe_load(cglobal((:PyExc_AttributeError, PYLIB), PyPtr)); end
pyexc_AttributeError_type(args...; kwargs...) = safe(unsafe_pyexc_AttributeError_type(args...; kwargs...))
export pyexc_AttributeError_type


pyerror_occurred_RuntimeError() = pyerror_occurred(pyexc_RuntimeError_type())
pyerror_occurred_RuntimeError(args...; kwargs...) = safe(unsafe_pyerror_occurred_RuntimeError(args...; kwargs...))
export pyerror_occurred_RuntimeError


const _pyabstractrealtype = pynull()
unsafe_pyabstractrealtype() = unsafe_cacheget!(_pyabstractrealtype) do; unsafe_pyimportattr("numbers", "Real"); end
pyabstractrealtype(args...; kwargs...) = safe(unsafe_pyabstractrealtype(args...; kwargs...))
export pyabstractrealtype


pyerror_set_UnboundLocalError() = pyerror_set(pyexc_UnboundLocalError_type())
pyerror_set_UnboundLocalError(arg) = pyerror_set(pyexc_UnboundLocalError_type(), arg)
pyerror_set_UnboundLocalError(args...; kwargs...) = safe(unsafe_pyerror_set_UnboundLocalError(args...; kwargs...))
export pyerror_set_UnboundLocalError


pyerror_occurred_UnicodeError() = pyerror_occurred(pyexc_UnicodeError_type())
pyerror_occurred_UnicodeError(args...; kwargs...) = safe(unsafe_pyerror_occurred_UnicodeError(args...; kwargs...))
export pyerror_occurred_UnicodeError


pyerror_occurred_ArithmeticError() = pyerror_occurred(pyexc_ArithmeticError_type())
pyerror_occurred_ArithmeticError(args...; kwargs...) = safe(unsafe_pyerror_occurred_ArithmeticError(args...; kwargs...))
export pyerror_occurred_ArithmeticError


const _pyexc_IndexError_type = pynull()
unsafe_pyexc_IndexError_type() = unsafe_cacheget!(_pyexc_IndexError_type) do; unsafe_load(cglobal((:PyExc_IndexError, PYLIB), PyPtr)); end
pyexc_IndexError_type(args...; kwargs...) = safe(unsafe_pyexc_IndexError_type(args...; kwargs...))
export pyexc_IndexError_type


unsafe_pyisabstracttextio(o) = unsafe_pyisinstance(o, pyabstracttextiotype())
pyisabstracttextio(args...; kwargs...) = safe(unsafe_pyisabstracttextio(args...; kwargs...))
export pyisabstracttextio


unsafe_pybytesio(args...; kwargs...) = unsafe_pycall_args(pybytesiotype(), args, kwargs)
pybytesio(args...; kwargs...) = safe(unsafe_pybytesio(args...; kwargs...))
export pybytesio


pyisbufferedwriterio(o) = unsafe_pytype_check(o, pybufferedwriteriotype())
pyisbufferedwriterio(args...; kwargs...) = safe(unsafe_pyisbufferedwriterio(args...; kwargs...))
export pyisbufferedwriterio


const _pyabstractsettype = pynull()
unsafe_pyabstractsettype() = unsafe_cacheget!(_pyabstractsettype) do; unsafe_pyimportattr("collections.abc", "Set"); end
pyabstractsettype(args...; kwargs...) = safe(unsafe_pyabstractsettype(args...; kwargs...))
export pyabstractsettype


pyerror_occurred_BaseException() = pyerror_occurred(pyexc_BaseException_type())
pyerror_occurred_BaseException(args...; kwargs...) = safe(unsafe_pyerror_occurred_BaseException(args...; kwargs...))
export pyerror_occurred_BaseException


const _pyabstractcontainertype = pynull()
unsafe_pyabstractcontainertype() = unsafe_cacheget!(_pyabstractcontainertype) do; unsafe_pyimportattr("collections.abc", "Container"); end
pyabstractcontainertype(args...; kwargs...) = safe(unsafe_pyabstractcontainertype(args...; kwargs...))
export pyabstractcontainertype


const _pyexc_UnicodeError_type = pynull()
unsafe_pyexc_UnicodeError_type() = unsafe_cacheget!(_pyexc_UnicodeError_type) do; unsafe_load(cglobal((:PyExc_UnicodeError, PYLIB), PyPtr)); end
pyexc_UnicodeError_type(args...; kwargs...) = safe(unsafe_pyexc_UnicodeError_type(args...; kwargs...))
export pyexc_UnicodeError_type


function unsafe_pyior(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceOr, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyior(args...; kwargs...) = safe(unsafe_pyior(args...; kwargs...))
export pyior


const _pyexc_NameError_type = pynull()
unsafe_pyexc_NameError_type() = unsafe_cacheget!(_pyexc_NameError_type) do; unsafe_load(cglobal((:PyExc_NameError, PYLIB), PyPtr)); end
pyexc_NameError_type(args...; kwargs...) = safe(unsafe_pyexc_NameError_type(args...; kwargs...))
export pyexc_NameError_type


const _pysettype = pynull()
unsafe_pysettype() = unsafe_cacheget!(_pysettype) do; cglobal((:PySet_Type, PYLIB), CPyObject); end
pysettype(args...; kwargs...) = safe(unsafe_pysettype(args...; kwargs...))
export pysettype


function unsafe_pycompare_obj(x1::Any, x2::Any, x3::CPy_CompareOp)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyObject_RichCompare, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}, CPy_CompareOp), x1, x2, x3)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pycompare_obj(args...; kwargs...) = safe(unsafe_pycompare_obj(args...; kwargs...))


const _pyexc_OverflowError_type = pynull()
unsafe_pyexc_OverflowError_type() = unsafe_cacheget!(_pyexc_OverflowError_type) do; unsafe_load(cglobal((:PyExc_OverflowError, PYLIB), PyPtr)); end
pyexc_OverflowError_type(args...; kwargs...) = safe(unsafe_pyexc_OverflowError_type(args...; kwargs...))
export pyexc_OverflowError_type


const _pyexc_BufferError_type = pynull()
unsafe_pyexc_BufferError_type() = unsafe_cacheget!(_pyexc_BufferError_type) do; unsafe_load(cglobal((:PyExc_BufferError, PYLIB), PyPtr)); end
pyexc_BufferError_type(args...; kwargs...) = safe(unsafe_pyexc_BufferError_type(args...; kwargs...))
export pyexc_BufferError_type


function unsafe_pyint_fromlonglong(x1::Any)
    r = ccall((:PyLong_FromLongLong, PYLIB), Ptr{Cvoid}, (Clonglong,), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


pyerror_occurred_NameError() = pyerror_occurred(pyexc_NameError_type())
pyerror_occurred_NameError(args...; kwargs...) = safe(unsafe_pyerror_occurred_NameError(args...; kwargs...))
export pyerror_occurred_NameError


function unsafe_pybytes(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyObject_Bytes, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
unsafe_pybytes(args...; kwargs...) = unsafe_pycall_args(pybytestype(), args, kwargs)
pybytes(args...; kwargs...) = safe(unsafe_pybytes(args...; kwargs...))
export pybytes


pyisexception(o) = unsafe_pytype_check_fast(o, CPy_TPFLAGS_BASE_EXC_SUBCLASS)
pyisexception(args...; kwargs...) = safe(unsafe_pyisexception(args...; kwargs...))
export pyisexception


pyissuper(o) = unsafe_pytype_check(o, pysupertype())
pyissuper(args...; kwargs...) = safe(unsafe_pyissuper(args...; kwargs...))
export pyissuper


function unsafe_pyabs(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_Absolute, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyabs(args...; kwargs...) = safe(unsafe_pyabs(args...; kwargs...))
export pyabs


function pyerror_set(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
    end

    r = ccall((:PyErr_SetNone, PYLIB), Cvoid, (Ptr{Cvoid},), x1)
    return r
end
function pyerror_set(x1::Any, x2::AbstractString)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
    end

    r = ccall((:PyErr_SetString, PYLIB), Cvoid, (Ptr{Cvoid}, Cstring), x1, x2)
    return r
end
function pyerror_set(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
    end

    r = ccall((:PyErr_SetObject, PYLIB), Cvoid, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    return r
end


const _pyexc_StopIteration_type = pynull()
unsafe_pyexc_StopIteration_type() = unsafe_cacheget!(_pyexc_StopIteration_type) do; unsafe_load(cglobal((:PyExc_StopIteration, PYLIB), PyPtr)); end
pyexc_StopIteration_type(args...; kwargs...) = safe(unsafe_pyexc_StopIteration_type(args...; kwargs...))
export pyexc_StopIteration_type


pyisrange(o) = unsafe_pytype_check(o, pyrangetype())
pyisrange(args...; kwargs...) = safe(unsafe_pyisrange(args...; kwargs...))
export pyisrange


function unsafe_pyxor(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Xor, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyxor(args...; kwargs...) = safe(unsafe_pyxor(args...; kwargs...))
export pyxor


const _pystrtype = pynull()
unsafe_pystrtype() = unsafe_cacheget!(_pystrtype) do; cglobal((:PyUnicode_Type, PYLIB), CPyObject); end
pystrtype(args...; kwargs...) = safe(unsafe_pystrtype(args...; kwargs...))
export pystrtype


unsafe_pyisabstractsequence(o) = unsafe_pyisinstance(o, pyabstractsequencetype())
pyisabstractsequence(args...; kwargs...) = safe(unsafe_pyisabstractsequence(args...; kwargs...))
export pyisabstractsequence


function unsafe_pystr_decodeutf8(x1::Any, x2::Any, x3::Any)
    r = ccall((:PyUnicode_DecodeUTF8, PYLIB), Ptr{Cvoid}, (Cstring, CPy_ssize_t, Cstring), x1, x2, x3)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


unsafe_pybufferedrandomio(args...; kwargs...) = unsafe_pycall_args(pybufferedrandomiotype(), args, kwargs)
pybufferedrandomio(args...; kwargs...) = safe(unsafe_pybufferedrandomio(args...; kwargs...))
export pybufferedrandomio


function unsafe_pyand(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_And, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyand(args...; kwargs...) = safe(unsafe_pyand(args...; kwargs...))
export pyand


function unsafe_pymod(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Remainder, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pymod(args...; kwargs...) = safe(unsafe_pymod(args...; kwargs...))
export pymod


function unsafe_pymul(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Multiply, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pymul(args...; kwargs...) = safe(unsafe_pymul(args...; kwargs...))
export pymul


unsafe_pytzinfo(args...; kwargs...) = unsafe_pycall_args(pytzinfotype(), args, kwargs)
pytzinfo(args...; kwargs...) = safe(unsafe_pytzinfo(args...; kwargs...))
export pytzinfo


unsafe_pyexec(args...; kwargs...) = unsafe_pycall_args(pyexecfunction(), args, kwargs)
pyexec(args...; kwargs...) = safe(unsafe_pyexec(args...; kwargs...))
export pyexec


unsafe_pyisabstractcomplex(o) = unsafe_pyisinstance(o, pyabstractcomplextype())
pyisabstractcomplex(args...; kwargs...) = safe(unsafe_pyisabstractcomplex(args...; kwargs...))
export pyisabstractcomplex


pyerror_set_StopIteration() = pyerror_set(pyexc_StopIteration_type())
pyerror_set_StopIteration(arg) = pyerror_set(pyexc_StopIteration_type(), arg)
pyerror_set_StopIteration(args...; kwargs...) = safe(unsafe_pyerror_set_StopIteration(args...; kwargs...))
export pyerror_set_StopIteration


pyisset(o) = unsafe_pytype_check(o, pysettype())
pyisset(args...; kwargs...) = safe(unsafe_pyisset(args...; kwargs...))
export pyisset


function unsafe_pypos(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_Positive, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pypos(args...; kwargs...) = safe(unsafe_pypos(args...; kwargs...))
export pypos


const _pyexc_UnicodeTranslateError_type = pynull()
unsafe_pyexc_UnicodeTranslateError_type() = unsafe_cacheget!(_pyexc_UnicodeTranslateError_type) do; unsafe_load(cglobal((:PyExc_UnicodeTranslateError, PYLIB), PyPtr)); end
pyexc_UnicodeTranslateError_type(args...; kwargs...) = safe(unsafe_pyexc_UnicodeTranslateError_type(args...; kwargs...))
export pyexc_UnicodeTranslateError_type


const _pyellipsis = pynull()
unsafe_pyellipsis() = unsafe_cacheget!(_pyellipsis) do; cglobal((:_Py_EllipsisObject, PYLIB), CPyObject); end
pyellipsis(args...; kwargs...) = safe(unsafe_pyellipsis(args...; kwargs...))
export pyellipsis


pyerror_set_RuntimeError() = pyerror_set(pyexc_RuntimeError_type())
pyerror_set_RuntimeError(arg) = pyerror_set(pyexc_RuntimeError_type(), arg)
pyerror_set_RuntimeError(args...; kwargs...) = safe(unsafe_pyerror_set_RuntimeError(args...; kwargs...))
export pyerror_set_RuntimeError


function unsafe_pyadd(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Add, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyadd(args...; kwargs...) = safe(unsafe_pyadd(args...; kwargs...))
export pyadd


pyerror_set_ArithmeticError() = pyerror_set(pyexc_ArithmeticError_type())
pyerror_set_ArithmeticError(arg) = pyerror_set(pyexc_ArithmeticError_type(), arg)
pyerror_set_ArithmeticError(args...; kwargs...) = safe(unsafe_pyerror_set_ArithmeticError(args...; kwargs...))
export pyerror_set_ArithmeticError


const _pybooltype = pynull()
unsafe_pybooltype() = unsafe_cacheget!(_pybooltype) do; cglobal((:PyBool_Type, PYLIB), CPyObject); end
pybooltype(args...; kwargs...) = safe(unsafe_pybooltype(args...; kwargs...))
export pybooltype


function unsafe_pylist_append(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyList_Append, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end


const _pyexc_SyntaxError_type = pynull()
unsafe_pyexc_SyntaxError_type() = unsafe_cacheget!(_pyexc_SyntaxError_type) do; unsafe_load(cglobal((:PyExc_SyntaxError, PYLIB), PyPtr)); end
pyexc_SyntaxError_type(args...; kwargs...) = safe(unsafe_pyexc_SyntaxError_type(args...; kwargs...))
export pyexc_SyntaxError_type


unsafe_pyisabstractset(o) = unsafe_pyisinstance(o, pyabstractsettype())
pyisabstractset(args...; kwargs...) = safe(unsafe_pyisabstractset(args...; kwargs...))
export pyisabstractset


const _pyinttype = pynull()
unsafe_pyinttype() = unsafe_cacheget!(_pyinttype) do; cglobal((:PyLong_Type, PYLIB), CPyObject); end
pyinttype(args...; kwargs...) = safe(unsafe_pyinttype(args...; kwargs...))
export pyinttype


function unsafe_pyindex(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_Index, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyindex(args...; kwargs...) = safe(unsafe_pyindex(args...; kwargs...))
export pyindex


pyisfrozenset(o) = unsafe_pytype_check(o, pyfrozensettype())
pyisfrozenset(args...; kwargs...) = safe(unsafe_pyisfrozenset(args...; kwargs...))
export pyisfrozenset


const _pyexc_IOUnsupportedOperation_type = pynull()
unsafe_pyexc_IOUnsupportedOperation_type() = unsafe_cacheget!(_pyexc_IOUnsupportedOperation_type) do; unsafe_pyimportattr("io", "UnsupportedOperation"); end
pyexc_IOUnsupportedOperation_type(args...; kwargs...) = safe(unsafe_pyexc_IOUnsupportedOperation_type(args...; kwargs...))
export pyexc_IOUnsupportedOperation_type


function unsafe_pyfloordiv(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_FloorDivide, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyfloordiv(args...; kwargs...) = safe(unsafe_pyfloordiv(args...; kwargs...))
export pyfloordiv


const _pyexc_NotImplementedError_type = pynull()
unsafe_pyexc_NotImplementedError_type() = unsafe_cacheget!(_pyexc_NotImplementedError_type) do; unsafe_load(cglobal((:PyExc_NotImplementedError, PYLIB), PyPtr)); end
pyexc_NotImplementedError_type(args...; kwargs...) = safe(unsafe_pyexc_NotImplementedError_type(args...; kwargs...))
export pyexc_NotImplementedError_type


pyerror_occurred_KeyError() = pyerror_occurred(pyexc_KeyError_type())
pyerror_occurred_KeyError(args...; kwargs...) = safe(unsafe_pyerror_occurred_KeyError(args...; kwargs...))
export pyerror_occurred_KeyError


pyisint(o) = unsafe_pytype_check_fast(o, CPy_TPFLAGS_LONG_SUBCLASS)
pyisint(args...; kwargs...) = safe(unsafe_pyisint(args...; kwargs...))
export pyisint


pyisstringio(o) = unsafe_pytype_check(o, pystringiotype())
pyisstringio(args...; kwargs...) = safe(unsafe_pyisstringio(args...; kwargs...))
export pyisstringio


function pyerror_givenexceptionmatches(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
    end

    r = ccall((:PyErr_GivenExceptionMatches, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    return (r != 0)
end


const _pybytestype = pynull()
unsafe_pybytestype() = unsafe_cacheget!(_pybytestype) do; cglobal((:PyBytes_Type, PYLIB), CPyObject); end
pybytestype(args...; kwargs...) = safe(unsafe_pybytestype(args...; kwargs...))
export pybytestype


const _pybuiltinsmodule = pynull()
unsafe_pybuiltinsmodule() = unsafe_cacheget!(_pybuiltinsmodule) do; pyimport("builtins"); end
pybuiltinsmodule(args...; kwargs...) = safe(unsafe_pybuiltinsmodule(args...; kwargs...))
export pybuiltinsmodule


function unsafe_pytruth(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Bool}()
    end

    r = ccall((:PyObject_IsTrue, PYLIB), Cint, (Ptr{Cvoid},), x1)
    if r == -1
        return ValueOrError{Bool}()
    else
        return ValueOrError{Bool}(r != 0)
    end
end
pytruth(args...; kwargs...) = safe(unsafe_pytruth(args...; kwargs...))
export pytruth


function unsafe_pyconcat(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PySequence_Concat, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyconcat(args...; kwargs...) = safe(unsafe_pyconcat(args...; kwargs...))
export pyconcat


function unsafe_pycontains(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Bool}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Bool}()
    end

    r = ccall((:PySequence_Contains, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == -1
        return ValueOrError{Bool}()
    else
        return ValueOrError{Bool}(r != 0)
    end
end
pycontains(args...; kwargs...) = safe(unsafe_pycontains(args...; kwargs...))
export pycontains


pyerror_occurred_ZeroDivisionError() = pyerror_occurred(pyexc_ZeroDivisionError_type())
pyerror_occurred_ZeroDivisionError(args...; kwargs...) = safe(unsafe_pyerror_occurred_ZeroDivisionError(args...; kwargs...))
export pyerror_occurred_ZeroDivisionError


const _pyabstractrawiotype = pynull()
unsafe_pyabstractrawiotype() = unsafe_cacheget!(_pyabstractrawiotype) do; unsafe_pyimportattr("io", "RawIOBase"); end
pyabstractrawiotype(args...; kwargs...) = safe(unsafe_pyabstractrawiotype(args...; kwargs...))
export pyabstractrawiotype


pyiscomplex(o) = unsafe_pytype_check(o, pycomplextype())
pyiscomplex(args...; kwargs...) = safe(unsafe_pyiscomplex(args...; kwargs...))
export pyiscomplex


pyerror_occurred_ImportError() = pyerror_occurred(pyexc_ImportError_type())
pyerror_occurred_ImportError(args...; kwargs...) = safe(unsafe_pyerror_occurred_ImportError(args...; kwargs...))
export pyerror_occurred_ImportError


function unsafe_pyiter(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyObject_GetIter, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyiter(args...; kwargs...) = safe(unsafe_pyiter(args...; kwargs...))
export pyiter


function unsafe_pyimod(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceRemainder, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyimod(args...; kwargs...) = safe(unsafe_pyimod(args...; kwargs...))
export pyimod


pyisfileio(o) = unsafe_pytype_check(o, pyfileiotype())
pyisfileio(args...; kwargs...) = safe(unsafe_pyisfileio(args...; kwargs...))
export pyisfileio


const _pyabstractbufferediotype = pynull()
unsafe_pyabstractbufferediotype() = unsafe_cacheget!(_pyabstractbufferediotype) do; unsafe_pyimportattr("io", "BufferedIOBase"); end
pyabstractbufferediotype(args...; kwargs...) = safe(unsafe_pyabstractbufferediotype(args...; kwargs...))
export pyabstractbufferediotype


unsafe_pybufferedwriterio(args...; kwargs...) = unsafe_pycall_args(pybufferedwriteriotype(), args, kwargs)
pybufferedwriterio(args...; kwargs...) = safe(unsafe_pybufferedwriterio(args...; kwargs...))
export pybufferedwriterio


const _pydatetimetype = pynull()
unsafe_pydatetimetype() = unsafe_cacheget!(_pydatetimetype) do; unsafe_pyimportattr("datetime", "datetime"); end
pydatetimetype(args...; kwargs...) = safe(unsafe_pydatetimetype(args...; kwargs...))
export pydatetimetype


pyerror_set_ZeroDivisionError() = pyerror_set(pyexc_ZeroDivisionError_type())
pyerror_set_ZeroDivisionError(arg) = pyerror_set(pyexc_ZeroDivisionError_type(), arg)
pyerror_set_ZeroDivisionError(args...; kwargs...) = safe(unsafe_pyerror_set_ZeroDivisionError(args...; kwargs...))
export pyerror_set_ZeroDivisionError


unsafe_pyfileio(args...; kwargs...) = unsafe_pycall_args(pyfileiotype(), args, kwargs)
pyfileio(args...; kwargs...) = safe(unsafe_pyfileio(args...; kwargs...))
export pyfileio


unsafe_pydatetime(args...; kwargs...) = unsafe_pycall_args(pydatetimetype(), args, kwargs)
pydatetime(args...; kwargs...) = safe(unsafe_pydatetime(args...; kwargs...))
export pydatetime


unsafe_pybool(args...; kwargs...) = unsafe_pycall_args(pybooltype(), args, kwargs)
pybool(args...; kwargs...) = safe(unsafe_pybool(args...; kwargs...))
export pybool


function unsafe_pyset_add(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Nothing}()
    end

    r = ccall((:PySet_Add, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end


const _pyexc_TabError_type = pynull()
unsafe_pyexc_TabError_type() = unsafe_cacheget!(_pyexc_TabError_type) do; unsafe_load(cglobal((:PyExc_TabError, PYLIB), PyPtr)); end
pyexc_TabError_type(args...; kwargs...) = safe(unsafe_pyexc_TabError_type(args...; kwargs...))
export pyexc_TabError_type


const _pydicttype = pynull()
unsafe_pydicttype() = unsafe_cacheget!(_pydicttype) do; cglobal((:PyDict_Type, PYLIB), CPyObject); end
pydicttype(args...; kwargs...) = safe(unsafe_pydicttype(args...; kwargs...))
export pydicttype


unsafe_pyslice(args...; kwargs...) = unsafe_pycall_args(pyslicetype(), args, kwargs)
pyslice(args...; kwargs...) = safe(unsafe_pyslice(args...; kwargs...))
export pyslice


const _pybufferedreaderiotype = pynull()
unsafe_pybufferedreaderiotype() = unsafe_cacheget!(_pybufferedreaderiotype) do; unsafe_pyimportattr("io", "BufferedReader"); end
pybufferedreaderiotype(args...; kwargs...) = safe(unsafe_pybufferedreaderiotype(args...; kwargs...))
export pybufferedreaderiotype


pyerror_set_TabError() = pyerror_set(pyexc_TabError_type())
pyerror_set_TabError(arg) = pyerror_set(pyexc_TabError_type(), arg)
pyerror_set_TabError(args...; kwargs...) = safe(unsafe_pyerror_set_TabError(args...; kwargs...))
export pyerror_set_TabError


pyerror_occurred_UnicodeEncodeError() = pyerror_occurred(pyexc_UnicodeEncodeError_type())
pyerror_occurred_UnicodeEncodeError(args...; kwargs...) = safe(unsafe_pyerror_occurred_UnicodeEncodeError(args...; kwargs...))
export pyerror_occurred_UnicodeEncodeError


function unsafe_pyisinstance(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Bool}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Bool}()
    end

    r = ccall((:PyObject_IsInstance, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == -1
        return ValueOrError{Bool}()
    else
        return ValueOrError{Bool}(r != 0)
    end
end
pyisinstance(args...; kwargs...) = safe(unsafe_pyisinstance(args...; kwargs...))
export pyisinstance


function unsafe_pynot(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Bool}()
    end

    r = ccall((:PyObject_Not, PYLIB), Cint, (Ptr{Cvoid},), x1)
    if r == -1
        return ValueOrError{Bool}()
    else
        return ValueOrError{Bool}(r != 0)
    end
end
pynot(args...; kwargs...) = safe(unsafe_pynot(args...; kwargs...))
export pynot


pyistuple(o) = unsafe_pytype_check_fast(o, CPy_TPFLAGS_TUPLE_SUBCLASS)
pyistuple(args...; kwargs...) = safe(unsafe_pyistuple(args...; kwargs...))
export pyistuple


pyerror_set_Exception() = pyerror_set(pyexc_Exception_type())
pyerror_set_Exception(arg) = pyerror_set(pyexc_Exception_type(), arg)
pyerror_set_Exception(args...; kwargs...) = safe(unsafe_pyerror_set_Exception(args...; kwargs...))
export pyerror_set_Exception


const _pysupertype = pynull()
unsafe_pysupertype() = unsafe_cacheget!(_pysupertype) do; cglobal((:PySuper_Type, PYLIB), CPyObject); end
pysupertype(args...; kwargs...) = safe(unsafe_pysupertype(args...; kwargs...))
export pysupertype


const _pytimetype = pynull()
unsafe_pytimetype() = unsafe_cacheget!(_pytimetype) do; unsafe_pyimportattr("datetime", "time"); end
pytimetype(args...; kwargs...) = safe(unsafe_pytimetype(args...; kwargs...))
export pytimetype


function unsafe_pyinv(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_Invert, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyinv(args...; kwargs...) = safe(unsafe_pyinv(args...; kwargs...))
export pyinv


const _pyhelpfunction = pynull()
unsafe_pyhelpfunction() = unsafe_cacheget!(_pyhelpfunction) do; unsafe_pybuiltin("help"); end
pyhelpfunction(args...; kwargs...) = safe(unsafe_pyhelpfunction(args...; kwargs...))


pyerror_occurred_SystemExit() = pyerror_occurred(pyexc_SystemExit_type())
pyerror_occurred_SystemExit(args...; kwargs...) = safe(unsafe_pyerror_occurred_SystemExit(args...; kwargs...))
export pyerror_occurred_SystemExit


pyerror_occurred_MemoryError() = pyerror_occurred(pyexc_MemoryError_type())
pyerror_occurred_MemoryError(args...; kwargs...) = safe(unsafe_pyerror_occurred_MemoryError(args...; kwargs...))
export pyerror_occurred_MemoryError


const _pyabstracttextiotype = pynull()
unsafe_pyabstracttextiotype() = unsafe_cacheget!(_pyabstracttextiotype) do; unsafe_pyimportattr("io", "TextIOBase"); end
pyabstracttextiotype(args...; kwargs...) = safe(unsafe_pyabstracttextiotype(args...; kwargs...))
export pyabstracttextiotype


const _pynone = pynull()
unsafe_pynone() = unsafe_cacheget!(_pynone) do; cglobal((:_Py_NoneStruct, PYLIB), CPyObject); end
pynone(args...; kwargs...) = safe(unsafe_pynone(args...; kwargs...))
export pynone


const _pyexc_ImportError_type = pynull()
unsafe_pyexc_ImportError_type() = unsafe_cacheget!(_pyexc_ImportError_type) do; unsafe_load(cglobal((:PyExc_ImportError, PYLIB), PyPtr)); end
pyexc_ImportError_type(args...; kwargs...) = safe(unsafe_pyexc_ImportError_type(args...; kwargs...))
export pyexc_ImportError_type


const _pyfileiotype = pynull()
unsafe_pyfileiotype() = unsafe_cacheget!(_pyfileiotype) do; unsafe_pyimportattr("io", "FileIO"); end
pyfileiotype(args...; kwargs...) = safe(unsafe_pyfileiotype(args...; kwargs...))
export pyfileiotype


unsafe_pybufferedrwio(args...; kwargs...) = unsafe_pycall_args(pybufferedrwiotype(), args, kwargs)
pybufferedrwio(args...; kwargs...) = safe(unsafe_pybufferedrwio(args...; kwargs...))
export pybufferedrwio


unsafe_pyisabstractiterable(o) = unsafe_pyisinstance(o, pyabstractiterabletype())
pyisabstractiterable(args...; kwargs...) = safe(unsafe_pyisabstractiterable(args...; kwargs...))
export pyisabstractiterable


const _pyobjecttype = pynull()
unsafe_pyobjecttype() = unsafe_cacheget!(_pyobjecttype) do; cglobal((:PyBaseObject_Type, PYLIB), CPyObject); end
pyobjecttype(args...; kwargs...) = safe(unsafe_pyobjecttype(args...; kwargs...))
export pyobjecttype


const _pyexc_UnboundLocalError_type = pynull()
unsafe_pyexc_UnboundLocalError_type() = unsafe_cacheget!(_pyexc_UnboundLocalError_type) do; unsafe_load(cglobal((:PyExc_UnboundLocalError, PYLIB), PyPtr)); end
pyexc_UnboundLocalError_type(args...; kwargs...) = safe(unsafe_pyexc_UnboundLocalError_type(args...; kwargs...))
export pyexc_UnboundLocalError_type


const _pyexc_LookupError_type = pynull()
unsafe_pyexc_LookupError_type() = unsafe_cacheget!(_pyexc_LookupError_type) do; unsafe_load(cglobal((:PyExc_LookupError, PYLIB), PyPtr)); end
pyexc_LookupError_type(args...; kwargs...) = safe(unsafe_pyexc_LookupError_type(args...; kwargs...))
export pyexc_LookupError_type


pyerror_set_BufferError() = pyerror_set(pyexc_BufferError_type())
pyerror_set_BufferError(arg) = pyerror_set(pyexc_BufferError_type(), arg)
pyerror_set_BufferError(args...; kwargs...) = safe(unsafe_pyerror_set_BufferError(args...; kwargs...))
export pyerror_set_BufferError


function unsafe_pytuple(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PySequence_Tuple, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
unsafe_pytuple(args...; kwargs...) = unsafe_pycall_args(pytupletype(), args, kwargs)
pytuple(args...; kwargs...) = safe(unsafe_pytuple(args...; kwargs...))
export pytuple


pyerror_occurred_SystemError() = pyerror_occurred(pyexc_SystemError_type())
pyerror_occurred_SystemError(args...; kwargs...) = safe(unsafe_pyerror_occurred_SystemError(args...; kwargs...))
export pyerror_occurred_SystemError


pyerror_occurred_EOFError() = pyerror_occurred(pyexc_EOFError_type())
pyerror_occurred_EOFError(args...; kwargs...) = safe(unsafe_pyerror_occurred_EOFError(args...; kwargs...))
export pyerror_occurred_EOFError


function unsafe_pymatmul(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_MatrixMultiply, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pymatmul(args...; kwargs...) = safe(unsafe_pymatmul(args...; kwargs...))
export pymatmul


unsafe_pytimezone(args...; kwargs...) = unsafe_pycall_args(pytimezonetype(), args, kwargs)
pytimezone(args...; kwargs...) = safe(unsafe_pytimezone(args...; kwargs...))
export pytimezone


pyisbool(o) = unsafe_pytype_check(o, pybooltype())
pyisbool(args...; kwargs...) = safe(unsafe_pyisbool(args...; kwargs...))
export pyisbool


pyerror_set_GeneratorExit() = pyerror_set(pyexc_GeneratorExit_type())
pyerror_set_GeneratorExit(arg) = pyerror_set(pyexc_GeneratorExit_type(), arg)
pyerror_set_GeneratorExit(args...; kwargs...) = safe(unsafe_pyerror_set_GeneratorExit(args...; kwargs...))
export pyerror_set_GeneratorExit


pyerror_occurred_UnicodeTranslateError() = pyerror_occurred(pyexc_UnicodeTranslateError_type())
pyerror_occurred_UnicodeTranslateError(args...; kwargs...) = safe(unsafe_pyerror_occurred_UnicodeTranslateError(args...; kwargs...))
export pyerror_occurred_UnicodeTranslateError


const _pyabstractintegraltype = pynull()
unsafe_pyabstractintegraltype() = unsafe_cacheget!(_pyabstractintegraltype) do; unsafe_pyimportattr("numbers", "Integral"); end
pyabstractintegraltype(args...; kwargs...) = safe(unsafe_pyabstractintegraltype(args...; kwargs...))
export pyabstractintegraltype


function unsafe_pyifloordiv(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceFloorDivide, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyifloordiv(args...; kwargs...) = safe(unsafe_pyifloordiv(args...; kwargs...))
export pyifloordiv


pyerror_set_UnicodeTranslateError() = pyerror_set(pyexc_UnicodeTranslateError_type())
pyerror_set_UnicodeTranslateError(arg) = pyerror_set(pyexc_UnicodeTranslateError_type(), arg)
pyerror_set_UnicodeTranslateError(args...; kwargs...) = safe(unsafe_pyerror_set_UnicodeTranslateError(args...; kwargs...))
export pyerror_set_UnicodeTranslateError


pyerror_set_SystemError() = pyerror_set(pyexc_SystemError_type())
pyerror_set_SystemError(arg) = pyerror_set(pyexc_SystemError_type(), arg)
pyerror_set_SystemError(args...; kwargs...) = safe(unsafe_pyerror_set_SystemError(args...; kwargs...))
export pyerror_set_SystemError


pyerror_set_SystemExit() = pyerror_set(pyexc_SystemExit_type())
pyerror_set_SystemExit(arg) = pyerror_set(pyexc_SystemExit_type(), arg)
pyerror_set_SystemExit(args...; kwargs...) = safe(unsafe_pyerror_set_SystemExit(args...; kwargs...))
export pyerror_set_SystemExit


function unsafe_pyidivmod(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceDivmod, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyidivmod(args...; kwargs...) = safe(unsafe_pyidivmod(args...; kwargs...))
export pyidivmod


const _pytupletype = pynull()
unsafe_pytupletype() = unsafe_cacheget!(_pytupletype) do; cglobal((:PyTuple_Type, PYLIB), CPyObject); end
pytupletype(args...; kwargs...) = safe(unsafe_pytupletype(args...; kwargs...))
export pytupletype


function unsafe_pydict_setitem(x1::Any, x2::Any, x3::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Nothing}()
    end

    if !isa(x3, AbstractPyRef)
        x3 = unsafe_pyobj(x3)
        isnull(x3) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyDict_SetItem, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), x1, x2, x3)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end


const _pyfloattype = pynull()
unsafe_pyfloattype() = unsafe_cacheget!(_pyfloattype) do; cglobal((:PyFloat_Type, PYLIB), CPyObject); end
pyfloattype(args...; kwargs...) = safe(unsafe_pyfloattype(args...; kwargs...))
export pyfloattype


const _pyabstractiterabletype = pynull()
unsafe_pyabstractiterabletype() = unsafe_cacheget!(_pyabstractiterabletype) do; unsafe_pyimportattr("collections.abc", "Iterable"); end
pyabstractiterabletype(args...; kwargs...) = safe(unsafe_pyabstractiterabletype(args...; kwargs...))
export pyabstractiterabletype


function unsafe_pyipos(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_InplacePositive, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyipos(args...; kwargs...) = safe(unsafe_pyipos(args...; kwargs...))
export pyipos


function unsafe_pygenericgetattr(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyObject_GenericGetAttr, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


function unsafe_pyfrozenset_new(x1::Ptr)
    r = ccall((:PyFrozenSet_New, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


const _pybufferedrandomiotype = pynull()
unsafe_pybufferedrandomiotype() = unsafe_cacheget!(_pybufferedrandomiotype) do; unsafe_pyimportattr("io", "BufferedRandom"); end
pybufferedrandomiotype(args...; kwargs...) = safe(unsafe_pybufferedrandomiotype(args...; kwargs...))
export pybufferedrandomiotype


pyerror_set_UnicodeEncodeError() = pyerror_set(pyexc_UnicodeEncodeError_type())
pyerror_set_UnicodeEncodeError(arg) = pyerror_set(pyexc_UnicodeEncodeError_type(), arg)
pyerror_set_UnicodeEncodeError(args...; kwargs...) = safe(unsafe_pyerror_set_UnicodeEncodeError(args...; kwargs...))
export pyerror_set_UnicodeEncodeError


unsafe_pyisabstractintegral(o) = unsafe_pyisinstance(o, pyabstractintegraltype())
pyisabstractintegral(args...; kwargs...) = safe(unsafe_pyisabstractintegral(args...; kwargs...))
export pyisabstractintegral


function unsafe_pydivmod(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Divmod, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pydivmod(args...; kwargs...) = safe(unsafe_pydivmod(args...; kwargs...))
export pydivmod


const _pybytearraytype = pynull()
unsafe_pybytearraytype() = unsafe_cacheget!(_pybytearraytype) do; cglobal((:PyByteArray_Type, PYLIB), CPyObject); end
pybytearraytype(args...; kwargs...) = safe(unsafe_pybytearraytype(args...; kwargs...))
export pybytearraytype


const _pyexecfunction = pynull()
unsafe_pyexecfunction() = unsafe_cacheget!(_pyexecfunction) do; unsafe_pybuiltin("exec"); end
pyexecfunction(args...; kwargs...) = safe(unsafe_pyexecfunction(args...; kwargs...))


const _pybytesiotype = pynull()
unsafe_pybytesiotype() = unsafe_cacheget!(_pybytesiotype) do; unsafe_pyimportattr("io", "BytesIO"); end
pybytesiotype(args...; kwargs...) = safe(unsafe_pybytesiotype(args...; kwargs...))
export pybytesiotype


const _pyexc_ZeroDivisionError_type = pynull()
unsafe_pyexc_ZeroDivisionError_type() = unsafe_cacheget!(_pyexc_ZeroDivisionError_type) do; unsafe_load(cglobal((:PyExc_ZeroDivisionError, PYLIB), PyPtr)); end
pyexc_ZeroDivisionError_type(args...; kwargs...) = safe(unsafe_pyexc_ZeroDivisionError_type(args...; kwargs...))
export pyexc_ZeroDivisionError_type


pyerror_occurred_OSError() = pyerror_occurred(pyexc_OSError_type())
pyerror_occurred_OSError(args...; kwargs...) = safe(unsafe_pyerror_occurred_OSError(args...; kwargs...))
export pyerror_occurred_OSError


const _pyrangetype = pynull()
unsafe_pyrangetype() = unsafe_cacheget!(_pyrangetype) do; unsafe_pybuiltin("range"); end
pyrangetype(args...; kwargs...) = safe(unsafe_pyrangetype(args...; kwargs...))
export pyrangetype


function unsafe_pyint_asulonglong(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Culonglong}()
    end

    r = ccall((:PyLong_AsUnsignedLongLong, PYLIB), Culonglong, (Ptr{Cvoid},), x1)
    if iszero(r + one(r)) && pyerror_occurred()
        return ValueOrError{Culonglong}()
    else
        return ValueOrError{Culonglong}(r)
    end
end


pyerror_occurred_ReferenceError() = pyerror_occurred(pyexc_ReferenceError_type())
pyerror_occurred_ReferenceError(args...; kwargs...) = safe(unsafe_pyerror_occurred_ReferenceError(args...; kwargs...))
export pyerror_occurred_ReferenceError


function unsafe_pyirepeat(x1::Any, x2::Integer)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PySequence_InPlaceRepeat, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, CPy_ssize_t), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyirepeat(args...; kwargs...) = safe(unsafe_pyirepeat(args...; kwargs...))
export pyirepeat


function unsafe_pyiconcat(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PySequence_InPlaceConcat, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyiconcat(args...; kwargs...) = safe(unsafe_pyiconcat(args...; kwargs...))
export pyiconcat


unsafe_pyobject(args...; kwargs...) = unsafe_pycall_args(pyobjecttype(), args, kwargs)
pyobject(args...; kwargs...) = safe(unsafe_pyobject(args...; kwargs...))
export pyobject


function unsafe_pytuple_new(x1::Any)
    r = ccall((:PyTuple_New, PYLIB), Ptr{Cvoid}, (CPy_ssize_t,), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


pyerror_set_ReferenceError() = pyerror_set(pyexc_ReferenceError_type())
pyerror_set_ReferenceError(arg) = pyerror_set(pyexc_ReferenceError_type(), arg)
pyerror_set_ReferenceError(args...; kwargs...) = safe(unsafe_pyerror_set_ReferenceError(args...; kwargs...))
export pyerror_set_ReferenceError


function unsafe_pyixor(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceXor, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyixor(args...; kwargs...) = safe(unsafe_pyixor(args...; kwargs...))
export pyixor


unsafe_pybytearray(args...; kwargs...) = unsafe_pycall_args(pybytearraytype(), args, kwargs)
pybytearray(args...; kwargs...) = safe(unsafe_pybytearray(args...; kwargs...))
export pybytearray


pyisbytesio(o) = unsafe_pytype_check(o, pybytesiotype())
pyisbytesio(args...; kwargs...) = safe(unsafe_pyisbytesio(args...; kwargs...))
export pyisbytesio


pyerror_set_OSError() = pyerror_set(pyexc_OSError_type())
pyerror_set_OSError(arg) = pyerror_set(pyexc_OSError_type(), arg)
pyerror_set_OSError(args...; kwargs...) = safe(unsafe_pyerror_set_OSError(args...; kwargs...))
export pyerror_set_OSError


pyerror_occurred_IndexError() = pyerror_occurred(pyexc_IndexError_type())
pyerror_occurred_IndexError(args...; kwargs...) = safe(unsafe_pyerror_occurred_IndexError(args...; kwargs...))
export pyerror_occurred_IndexError


pyerror_set_IOUnsupportedOperation() = pyerror_set(pyexc_IOUnsupportedOperation_type())
pyerror_set_IOUnsupportedOperation(arg) = pyerror_set(pyexc_IOUnsupportedOperation_type(), arg)
pyerror_set_IOUnsupportedOperation(args...; kwargs...) = safe(unsafe_pyerror_set_IOUnsupportedOperation(args...; kwargs...))
export pyerror_set_IOUnsupportedOperation


const _pybufferedwriteriotype = pynull()
unsafe_pybufferedwriteriotype() = unsafe_cacheget!(_pybufferedwriteriotype) do; unsafe_pyimportattr("io", "BufferedWriter"); end
pybufferedwriteriotype(args...; kwargs...) = safe(unsafe_pybufferedwriteriotype(args...; kwargs...))
export pybufferedwriteriotype


const _pyexc_GeneratorExit_type = pynull()
unsafe_pyexc_GeneratorExit_type() = unsafe_cacheget!(_pyexc_GeneratorExit_type) do; unsafe_load(cglobal((:PyExc_GeneratorExit, PYLIB), PyPtr)); end
pyexc_GeneratorExit_type(args...; kwargs...) = safe(unsafe_pyexc_GeneratorExit_type(args...; kwargs...))
export pyexc_GeneratorExit_type


function unsafe_pyipow(x1::Any, x2::Any, x3::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    if !isa(x3, AbstractPyRef)
        x3 = unsafe_pyobj(x3)
        isnull(x3) && return PYNULL
    end

    r = ccall((:PyNumber_InplacePower, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), x1, x2, x3)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyipow(args...; kwargs...) = safe(unsafe_pyipow(args...; kwargs...))
export pyipow


function unsafe_pyset_new(x1::Ptr)
    r = ccall((:PySet_New, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


unsafe_pyfraction(args...; kwargs...) = unsafe_pycall_args(pyfractiontype(), args, kwargs)
pyfraction(args...; kwargs...) = safe(unsafe_pyfraction(args...; kwargs...))
export pyfraction


pyerror_set_UnicodeDecodeError() = pyerror_set(pyexc_UnicodeDecodeError_type())
pyerror_set_UnicodeDecodeError(arg) = pyerror_set(pyexc_UnicodeDecodeError_type(), arg)
pyerror_set_UnicodeDecodeError(args...; kwargs...) = safe(unsafe_pyerror_set_UnicodeDecodeError(args...; kwargs...))
export pyerror_set_UnicodeDecodeError


function unsafe_pyineg(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceNegative, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyineg(args...; kwargs...) = safe(unsafe_pyineg(args...; kwargs...))
export pyineg


pyerror_occurred_TabError() = pyerror_occurred(pyexc_TabError_type())
pyerror_occurred_TabError(args...; kwargs...) = safe(unsafe_pyerror_occurred_TabError(args...; kwargs...))
export pyerror_occurred_TabError


const _pyexc_ReferenceError_type = pynull()
unsafe_pyexc_ReferenceError_type() = unsafe_cacheget!(_pyexc_ReferenceError_type) do; unsafe_load(cglobal((:PyExc_ReferenceError, PYLIB), PyPtr)); end
pyexc_ReferenceError_type(args...; kwargs...) = safe(unsafe_pyexc_ReferenceError_type(args...; kwargs...))
export pyexc_ReferenceError_type


pyerror_occurred_StopIteration() = pyerror_occurred(pyexc_StopIteration_type())
pyerror_occurred_StopIteration(args...; kwargs...) = safe(unsafe_pyerror_occurred_StopIteration(args...; kwargs...))
export pyerror_occurred_StopIteration


function unsafe_pystr(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyObject_Str, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
unsafe_pystr(args...; kwargs...) = unsafe_pycall_args(pystrtype(), args, kwargs)
pystr(args...; kwargs...) = safe(unsafe_pystr(args...; kwargs...))
export pystr


const _pyabstractmappingtype = pynull()
unsafe_pyabstractmappingtype() = unsafe_cacheget!(_pyabstractmappingtype) do; unsafe_pyimportattr("collections.abc", "Mapping"); end
pyabstractmappingtype(args...; kwargs...) = safe(unsafe_pyabstractmappingtype(args...; kwargs...))
export pyabstractmappingtype


pyerror_occurred_IndentationError() = pyerror_occurred(pyexc_IndentationError_type())
pyerror_occurred_IndentationError(args...; kwargs...) = safe(unsafe_pyerror_occurred_IndentationError(args...; kwargs...))
export pyerror_occurred_IndentationError


function unsafe_pygetattr(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyObject_GetAttr, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
function unsafe_pygetattr(x1::Any, x2::AbstractString)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyObject_GetAttrString, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Cstring), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pygetattr(args...; kwargs...) = safe(unsafe_pygetattr(args...; kwargs...))
export pygetattr


unsafe_pyset(args...; kwargs...) = unsafe_pycall_args(pysettype(), args, kwargs)
pyset(args...; kwargs...) = safe(unsafe_pyset(args...; kwargs...))
export pyset


function unsafe_pysub(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Subtract, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pysub(args...; kwargs...) = safe(unsafe_pysub(args...; kwargs...))
export pysub


const _pyexc_FloatingPointError_type = pynull()
unsafe_pyexc_FloatingPointError_type() = unsafe_cacheget!(_pyexc_FloatingPointError_type) do; unsafe_load(cglobal((:PyExc_FloatingPointError, PYLIB), PyPtr)); end
pyexc_FloatingPointError_type(args...; kwargs...) = safe(unsafe_pyexc_FloatingPointError_type(args...; kwargs...))
export pyexc_FloatingPointError_type


const _pyexc_UnicodeEncodeError_type = pynull()
unsafe_pyexc_UnicodeEncodeError_type() = unsafe_cacheget!(_pyexc_UnicodeEncodeError_type) do; unsafe_load(cglobal((:PyExc_UnicodeEncodeError, PYLIB), PyPtr)); end
pyexc_UnicodeEncodeError_type(args...; kwargs...) = safe(unsafe_pyexc_UnicodeEncodeError_type(args...; kwargs...))
export pyexc_UnicodeEncodeError_type


const _pyexc_UnicodeDecodeError_type = pynull()
unsafe_pyexc_UnicodeDecodeError_type() = unsafe_cacheget!(_pyexc_UnicodeDecodeError_type) do; unsafe_load(cglobal((:PyExc_UnicodeDecodeError, PYLIB), PyPtr)); end
pyexc_UnicodeDecodeError_type(args...; kwargs...) = safe(unsafe_pyexc_UnicodeDecodeError_type(args...; kwargs...))
export pyexc_UnicodeDecodeError_type


const _pyexc_KeyboardInterrupt_type = pynull()
unsafe_pyexc_KeyboardInterrupt_type() = unsafe_cacheget!(_pyexc_KeyboardInterrupt_type) do; unsafe_load(cglobal((:PyExc_KeyboardInterrupt, PYLIB), PyPtr)); end
pyexc_KeyboardInterrupt_type(args...; kwargs...) = safe(unsafe_pyexc_KeyboardInterrupt_type(args...; kwargs...))
export pyexc_KeyboardInterrupt_type


pyistype(o) = unsafe_pytype_check_fast(o, CPy_TPFLAGS_TYPE_SUBCLASS)
pyistype(args...; kwargs...) = safe(unsafe_pyistype(args...; kwargs...))
export pyistype


unsafe_pyhelp(args...; kwargs...) = unsafe_pycall_args(pyhelpfunction(), args, kwargs)
pyhelp(args...; kwargs...) = safe(unsafe_pyhelp(args...; kwargs...))
export pyhelp


function unsafe_pydir(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyObject_Dir, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pydir(args...; kwargs...) = safe(unsafe_pydir(args...; kwargs...))
export pydir


pyisbytearray(o) = unsafe_pytype_check(o, pybytearraytype())
pyisbytearray(args...; kwargs...) = safe(unsafe_pyisbytearray(args...; kwargs...))
export pyisbytearray


pyerror_set_MemoryError() = pyerror_set(pyexc_MemoryError_type())
pyerror_set_MemoryError(arg) = pyerror_set(pyexc_MemoryError_type(), arg)
pyerror_set_MemoryError(args...; kwargs...) = safe(unsafe_pyerror_set_MemoryError(args...; kwargs...))
export pyerror_set_MemoryError


pyerror_occurred_UnboundLocalError() = pyerror_occurred(pyexc_UnboundLocalError_type())
pyerror_occurred_UnboundLocalError(args...; kwargs...) = safe(unsafe_pyerror_occurred_UnboundLocalError(args...; kwargs...))
export pyerror_occurred_UnboundLocalError


const _pyexc_EOFError_type = pynull()
unsafe_pyexc_EOFError_type() = unsafe_cacheget!(_pyexc_EOFError_type) do; unsafe_load(cglobal((:PyExc_EOFError, PYLIB), PyPtr)); end
pyexc_EOFError_type(args...; kwargs...) = safe(unsafe_pyexc_EOFError_type(args...; kwargs...))
export pyexc_EOFError_type


const _pyexc_IndentationError_type = pynull()
unsafe_pyexc_IndentationError_type() = unsafe_cacheget!(_pyexc_IndentationError_type) do; unsafe_load(cglobal((:PyExc_IndentationError, PYLIB), PyPtr)); end
pyexc_IndentationError_type(args...; kwargs...) = safe(unsafe_pyexc_IndentationError_type(args...; kwargs...))
export pyexc_IndentationError_type


const _pyabstractnumbertype = pynull()
unsafe_pyabstractnumbertype() = unsafe_cacheget!(_pyabstractnumbertype) do; unsafe_pyimportattr("numbers", "Number"); end
pyabstractnumbertype(args...; kwargs...) = safe(unsafe_pyabstractnumbertype(args...; kwargs...))
export pyabstractnumbertype


pyerror_occurred_OverflowError() = pyerror_occurred(pyexc_OverflowError_type())
pyerror_occurred_OverflowError(args...; kwargs...) = safe(unsafe_pyerror_occurred_OverflowError(args...; kwargs...))
export pyerror_occurred_OverflowError


function unsafe_pytruediv(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_TrueDivide, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pytruediv(args...; kwargs...) = safe(unsafe_pytruediv(args...; kwargs...))
export pytruediv


unsafe_pyisabstractcontainer(o) = unsafe_pyisinstance(o, pyabstractcontainertype())
pyisabstractcontainer(args...; kwargs...) = safe(unsafe_pyisabstractcontainer(args...; kwargs...))
export pyisabstractcontainer


unsafe_pyisabstractio(o) = unsafe_pyisinstance(o, pyabstractiotype())
pyisabstractio(args...; kwargs...) = safe(unsafe_pyisabstractio(args...; kwargs...))
export pyisabstractio


const _pyexc_SystemError_type = pynull()
unsafe_pyexc_SystemError_type() = unsafe_cacheget!(_pyexc_SystemError_type) do; unsafe_load(cglobal((:PyExc_SystemError, PYLIB), PyPtr)); end
pyexc_SystemError_type(args...; kwargs...) = safe(unsafe_pyexc_SystemError_type(args...; kwargs...))
export pyexc_SystemError_type


const _pylisttype = pynull()
unsafe_pylisttype() = unsafe_cacheget!(_pylisttype) do; cglobal((:PyList_Type, PYLIB), CPyObject); end
pylisttype(args...; kwargs...) = safe(unsafe_pylisttype(args...; kwargs...))
export pylisttype


const _pyexc_OSError_type = pynull()
unsafe_pyexc_OSError_type() = unsafe_cacheget!(_pyexc_OSError_type) do; unsafe_load(cglobal((:PyExc_OSError, PYLIB), PyPtr)); end
pyexc_OSError_type(args...; kwargs...) = safe(unsafe_pyexc_OSError_type(args...; kwargs...))
export pyexc_OSError_type


function unsafe_pytuple_size(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return nothing
    end

    r = ccall((:PyTuple_Size, PYLIB), CPy_ssize_t, (Ptr{Cvoid},), x1)
    return r
end


pyerror_set_ImportError() = pyerror_set(pyexc_ImportError_type())
pyerror_set_ImportError(arg) = pyerror_set(pyexc_ImportError_type(), arg)
pyerror_set_ImportError(args...; kwargs...) = safe(unsafe_pyerror_set_ImportError(args...; kwargs...))
export pyerror_set_ImportError


function unsafe_pyrepeat(x1::Any, x2::Integer)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PySequence_Repeat, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, CPy_ssize_t), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyrepeat(args...; kwargs...) = safe(unsafe_pyrepeat(args...; kwargs...))
export pyrepeat


function unsafe_pysetitem(x1::Any, x2::Any, x3::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Nothing}()
    end

    if !isa(x3, AbstractPyRef)
        x3 = unsafe_pyobj(x3)
        isnull(x3) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyObject_SetItem, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), x1, x2, x3)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end
pysetitem(args...; kwargs...) = safe(unsafe_pysetitem(args...; kwargs...))
export pysetitem


function unsafe_pyisub(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceSubtract, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyisub(args...; kwargs...) = safe(unsafe_pyisub(args...; kwargs...))
export pyisub


function unsafe_pylist_new(x1::Any)
    r = ccall((:PyList_New, PYLIB), Ptr{Cvoid}, (CPy_ssize_t,), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end


function unsafe_pysetattr(x1::Any, x2::Any, x3::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return ValueOrError{Nothing}()
    end

    if !isa(x3, AbstractPyRef)
        x3 = unsafe_pyobj(x3)
        isnull(x3) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyObject_SetAttr, PYLIB), Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), x1, x2, x3)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end
function unsafe_pysetattr(x1::Any, x2::AbstractString, x3::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Nothing}()
    end

    if !isa(x3, AbstractPyRef)
        x3 = unsafe_pyobj(x3)
        isnull(x3) && return ValueOrError{Nothing}()
    end

    r = ccall((:PyObject_SetAttrString, PYLIB), Cint, (Ptr{Cvoid}, Cstring, Ptr{Cvoid}), x1, x2, x3)
    if r == -1
        return ValueOrError{Nothing}()
    else
        return ValueOrError{Nothing}(nothing)
    end
end
pysetattr(args...; kwargs...) = safe(unsafe_pysetattr(args...; kwargs...))
export pysetattr


const _pyslicetype = pynull()
unsafe_pyslicetype() = unsafe_cacheget!(_pyslicetype) do; cglobal((:PySlice_Type, PYLIB), CPyObject); end
pyslicetype(args...; kwargs...) = safe(unsafe_pyslicetype(args...; kwargs...))
export pyslicetype


pyisbufferedreaderio(o) = unsafe_pytype_check(o, pybufferedreaderiotype())
pyisbufferedreaderio(args...; kwargs...) = safe(unsafe_pyisbufferedreaderio(args...; kwargs...))
export pyisbufferedreaderio


function unsafe_pyrepr(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyObject_Repr, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyrepr(args...; kwargs...) = safe(unsafe_pyrepr(args...; kwargs...))
export pyrepr


unsafe_pyisabstractmapping(o) = unsafe_pyisinstance(o, pyabstractmappingtype())
pyisabstractmapping(args...; kwargs...) = safe(unsafe_pyisabstractmapping(args...; kwargs...))
export pyisabstractmapping


pyisbufferedrwio(o) = unsafe_pytype_check(o, pybufferedrwiotype())
pyisbufferedrwio(args...; kwargs...) = safe(unsafe_pyisbufferedrwio(args...; kwargs...))
export pyisbufferedrwio


const _pytypetype = pynull()
unsafe_pytypetype() = unsafe_cacheget!(_pytypetype) do; cglobal((:PyType_Type, PYLIB), CPyObject); end
pytypetype(args...; kwargs...) = safe(unsafe_pytypetype(args...; kwargs...))
export pytypetype


function unsafe_pyiinv(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceInvert, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyiinv(args...; kwargs...) = safe(unsafe_pyiinv(args...; kwargs...))
export pyiinv


pyerror_set_OverflowError() = pyerror_set(pyexc_OverflowError_type())
pyerror_set_OverflowError(arg) = pyerror_set(pyexc_OverflowError_type(), arg)
pyerror_set_OverflowError(args...; kwargs...) = safe(unsafe_pyerror_set_OverflowError(args...; kwargs...))
export pyerror_set_OverflowError


function unsafe_pyfloat_asdouble(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Cdouble}()
    end

    r = ccall((:PyFloat_AsDouble, PYLIB), Cdouble, (Ptr{Cvoid},), x1)
    if iszero(r + one(r)) && pyerror_occurred()
        return ValueOrError{Cdouble}()
    else
        return ValueOrError{Cdouble}(r)
    end
end


const _pyabstractsequencetype = pynull()
unsafe_pyabstractsequencetype() = unsafe_cacheget!(_pyabstractsequencetype) do; unsafe_pyimportattr("collections.abc", "Sequence"); end
pyabstractsequencetype(args...; kwargs...) = safe(unsafe_pyabstractsequencetype(args...; kwargs...))
export pyabstractsequencetype


const _pyfrozensettype = pynull()
unsafe_pyfrozensettype() = unsafe_cacheget!(_pyfrozensettype) do; cglobal((:PyFrozenSet_Type, PYLIB), CPyObject); end
pyfrozensettype(args...; kwargs...) = safe(unsafe_pyfrozensettype(args...; kwargs...))
export pyfrozensettype


function unsafe_pycomplex_imagasdouble(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{Cdouble}()
    end

    r = ccall((:PyComplex_ImagAsDouble, PYLIB), Cdouble, (Ptr{Cvoid},), x1)
    if iszero(r + one(r)) && pyerror_occurred()
        return ValueOrError{Cdouble}()
    else
        return ValueOrError{Cdouble}(r)
    end
end


function unsafe_pydict()
    r = ccall((:PyDict_New, PYLIB), Ptr{Cvoid}, (), )
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
unsafe_pydict(args...; kwargs...) = unsafe_pycall_args(pydicttype(), args, kwargs)
pydict(args...; kwargs...) = safe(unsafe_pydict(args...; kwargs...))
export pydict


function unsafe_pyor(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Or, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyor(args...; kwargs...) = safe(unsafe_pyor(args...; kwargs...))
export pyor


unsafe_pydate(args...; kwargs...) = unsafe_pycall_args(pydatetype(), args, kwargs)
pydate(args...; kwargs...) = safe(unsafe_pydate(args...; kwargs...))
export pydate


const _pytrue = pynull()
unsafe_pytrue() = unsafe_cacheget!(_pytrue) do; cglobal((:_Py_TrueStruct, PYLIB), CPyObject); end
pytrue(args...; kwargs...) = safe(unsafe_pytrue(args...; kwargs...))
export pytrue


function unsafe_pyint(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyNumber_Long, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
unsafe_pyint(args...; kwargs...) = unsafe_pycall_args(pyinttype(), args, kwargs)
pyint(args...; kwargs...) = safe(unsafe_pyint(args...; kwargs...))
export pyint


const _pyexc_TypeError_type = pynull()
unsafe_pyexc_TypeError_type() = unsafe_cacheget!(_pyexc_TypeError_type) do; unsafe_load(cglobal((:PyExc_TypeError, PYLIB), PyPtr)); end
pyexc_TypeError_type(args...; kwargs...) = safe(unsafe_pyexc_TypeError_type(args...; kwargs...))
export pyexc_TypeError_type


unsafe_pyisabstractreal(o) = unsafe_pyisinstance(o, pyabstractrealtype())
pyisabstractreal(args...; kwargs...) = safe(unsafe_pyisabstractreal(args...; kwargs...))
export pyisabstractreal


pyerror_occurred_GeneratorExit() = pyerror_occurred(pyexc_GeneratorExit_type())
pyerror_occurred_GeneratorExit(args...; kwargs...) = safe(unsafe_pyerror_occurred_GeneratorExit(args...; kwargs...))
export pyerror_occurred_GeneratorExit


function unsafe_pygetitem(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyObject_GetItem, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pygetitem(args...; kwargs...) = safe(unsafe_pygetitem(args...; kwargs...))
export pygetitem


pyerror_set_BaseException() = pyerror_set(pyexc_BaseException_type())
pyerror_set_BaseException(arg) = pyerror_set(pyexc_BaseException_type(), arg)
pyerror_set_BaseException(args...; kwargs...) = safe(unsafe_pyerror_set_BaseException(args...; kwargs...))
export pyerror_set_BaseException


unsafe_pystringio(args...; kwargs...) = unsafe_pycall_args(pystringiotype(), args, kwargs)
pystringio(args...; kwargs...) = safe(unsafe_pystringio(args...; kwargs...))
export pystringio


pyerror_set_AttributeError() = pyerror_set(pyexc_AttributeError_type())
pyerror_set_AttributeError(arg) = pyerror_set(pyexc_AttributeError_type(), arg)
pyerror_set_AttributeError(args...; kwargs...) = safe(unsafe_pyerror_set_AttributeError(args...; kwargs...))
export pyerror_set_AttributeError


pyisstr(o) = unsafe_pytype_check_fast(o, CPy_TPFLAGS_UNICODE_SUBCLASS)
pyisstr(args...; kwargs...) = safe(unsafe_pyisstr(args...; kwargs...))
export pyisstr


pyerror_set_FloatingPointError() = pyerror_set(pyexc_FloatingPointError_type())
pyerror_set_FloatingPointError(arg) = pyerror_set(pyexc_FloatingPointError_type(), arg)
pyerror_set_FloatingPointError(args...; kwargs...) = safe(unsafe_pyerror_set_FloatingPointError(args...; kwargs...))
export pyerror_set_FloatingPointError


const _pyexc_MemoryError_type = pynull()
unsafe_pyexc_MemoryError_type() = unsafe_cacheget!(_pyexc_MemoryError_type) do; unsafe_load(cglobal((:PyExc_MemoryError, PYLIB), PyPtr)); end
pyexc_MemoryError_type(args...; kwargs...) = safe(unsafe_pyexc_MemoryError_type(args...; kwargs...))
export pyexc_MemoryError_type


pyisbufferedrandomio(o) = unsafe_pytype_check(o, pybufferedrandomiotype())
pyisbufferedrandomio(args...; kwargs...) = safe(unsafe_pyisbufferedrandomio(args...; kwargs...))
export pyisbufferedrandomio


function unsafe_pyascii(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PyObject_ASCII, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyascii(args...; kwargs...) = safe(unsafe_pyascii(args...; kwargs...))
export pyascii


pyerror_occurred_AssertionError() = pyerror_occurred(pyexc_AssertionError_type())
pyerror_occurred_AssertionError(args...; kwargs...) = safe(unsafe_pyerror_occurred_AssertionError(args...; kwargs...))
export pyerror_occurred_AssertionError


unsafe_pytype(args...; kwargs...) = unsafe_pycall_args(pytypetype(), args, kwargs)
pytype(args...; kwargs...) = safe(unsafe_pytype(args...; kwargs...))
export pytype


function unsafe_pycomplex(x1::Real, x2::Real)
    r = ccall((:PyComplex_FromDoubles, PYLIB), Ptr{Cvoid}, (Cdouble, Cdouble), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
unsafe_pycomplex(args...; kwargs...) = unsafe_pycall_args(pycomplextype(), args, kwargs)
pycomplex(args...; kwargs...) = safe(unsafe_pycomplex(args...; kwargs...))
export pycomplex


function unsafe_pyrshift(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_Rshift, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyrshift(args...; kwargs...) = safe(unsafe_pyrshift(args...; kwargs...))
export pyrshift


function unsafe_pylen(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return ValueOrError{CPy_ssize_t}()
    end

    r = ccall((:PyObject_Length, PYLIB), CPy_ssize_t, (Ptr{Cvoid},), x1)
    if iszero(r + one(r))
        return ValueOrError{CPy_ssize_t}()
    else
        return ValueOrError{CPy_ssize_t}(r)
    end
end
pylen(args...; kwargs...) = safe(unsafe_pylen(args...; kwargs...))
export pylen


pyerror_occurred_UnicodeDecodeError() = pyerror_occurred(pyexc_UnicodeDecodeError_type())
pyerror_occurred_UnicodeDecodeError(args...; kwargs...) = safe(unsafe_pyerror_occurred_UnicodeDecodeError(args...; kwargs...))
export pyerror_occurred_UnicodeDecodeError


unsafe_pytextiowrapper(args...; kwargs...) = unsafe_pycall_args(pytextiowrappertype(), args, kwargs)
pytextiowrapper(args...; kwargs...) = safe(unsafe_pytextiowrapper(args...; kwargs...))
export pytextiowrapper


pyerror_occurred_NotImplementedError() = pyerror_occurred(pyexc_NotImplementedError_type())
pyerror_occurred_NotImplementedError(args...; kwargs...) = safe(unsafe_pyerror_occurred_NotImplementedError(args...; kwargs...))
export pyerror_occurred_NotImplementedError


function unsafe_pylist(x1::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    r = ccall((:PySequence_List, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid},), x1)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
unsafe_pylist(args...; kwargs...) = unsafe_pycall_args(pylisttype(), args, kwargs)
pylist(args...; kwargs...) = safe(unsafe_pylist(args...; kwargs...))
export pylist


unsafe_pytime(args...; kwargs...) = unsafe_pycall_args(pytimetype(), args, kwargs)
pytime(args...; kwargs...) = safe(unsafe_pytime(args...; kwargs...))
export pytime


pyerror_set_UnicodeError() = pyerror_set(pyexc_UnicodeError_type())
pyerror_set_UnicodeError(arg) = pyerror_set(pyexc_UnicodeError_type(), arg)
pyerror_set_UnicodeError(args...; kwargs...) = safe(unsafe_pyerror_set_UnicodeError(args...; kwargs...))
export pyerror_set_UnicodeError


function unsafe_pyiand(x1::Any, x2::Any)
    if !isa(x1, AbstractPyRef)
        x1 = unsafe_pyobj(x1)
        isnull(x1) && return PYNULL
    end

    if !isa(x2, AbstractPyRef)
        x2 = unsafe_pyobj(x2)
        isnull(x2) && return PYNULL
    end

    r = ccall((:PyNumber_InplaceAnd, PYLIB), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), x1, x2)
    if r == C_NULL
        return PYNULL
    else
        return unsafe_pyobj(PyRef(r, false))
    end
end
pyiand(args...; kwargs...) = safe(unsafe_pyiand(args...; kwargs...))
export pyiand


pyisbytes(o) = unsafe_pytype_check_fast(o, CPy_TPFLAGS_BYTES_SUBCLASS)
pyisbytes(args...; kwargs...) = safe(unsafe_pyisbytes(args...; kwargs...))
export pyisbytes


