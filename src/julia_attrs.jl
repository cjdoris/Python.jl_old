# *** THIS FILE IS AUTOMATICALLY GENERATED ***

### IO.seek

pyjulia_attrkind(::Val{:seek}, ::Type{T}) where {T<:IO} =
    (hasmethod(position, Tuple{T}) && hasmethod(seek, Tuple{T,Int}) && hasmethod(seekstart, Tuple{T}) && hasmethod(seekend, Tuple{T})) ? :method :
    :method

pyjulia_attrdef(::Val{:seek}, ::Type{T}) where {T<:IO} =
    (hasmethod(position, Tuple{T}) && hasmethod(seek, Tuple{T,Int}) && hasmethod(seekstart, Tuple{T}) && hasmethod(seekend, Tuple{T})) ? pyjulia_attrdef(Val(:seek), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:seek), T, IO, Val(2))

const _pyjulia_implmethod_seek_1_1 = function (o, _a)
    n, wh = @safe @unsafe_pyargparse _a (offset::Int, whence::Int=0)
    if wh == 0
        seekstart(o)
        seek(o, position(o) + n)
    elseif wh == 1
        seek(o, n)
    elseif wh == 2
        seekend(o)
        seek(o, position(o) + n)
    else
        pyerror_set_IOUnsupportedOperation("seek with whence = $wh")
        @goto error
    end
    return unsafe_pyint(position(o))
    @label error
    return PYNULL
end
function pyjulia_implmethod_seek_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_seek_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:seek}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "seek",
    meth = @cfunction(pyjulia_implmethod_seek_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)

const _pyjulia_implmethod_seek_1_2 = (o, a) -> (pyerror_set_IOUnsupportedOperation("seek"); PYNULL)
function pyjulia_implmethod_seek_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_seek_1_2(x1, x2))
    return r
end

pyjulia_attrdef(::Val{:seek}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "seek",
    meth = @cfunction(pyjulia_implmethod_seek_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)


### IO.close

pyjulia_attrkind(::Val{:close}, ::Type{T}) where {T<:IO} =
    (hasmethod(close, Tuple{T})) ? :method :
    :method

pyjulia_attrdef(::Val{:close}, ::Type{T}) where {T<:IO} =
    (hasmethod(close, Tuple{T})) ? pyjulia_attrdef(Val(:close), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:close), T, IO, Val(2))

const _pyjulia_implmethod_close_1_1 = o -> (close(o); unsafe_pynone())
function pyjulia_implmethod_close_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_close_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:close}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "close",
    meth = @cfunction(pyjulia_implmethod_close_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)

const _pyjulia_implmethod_close_1_2 = o -> (pyerror_set_IOUnsupportedOperation("close"); PYNULL)
function pyjulia_implmethod_close_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_close_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:close}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "close",
    meth = @cfunction(pyjulia_implmethod_close_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### IO.isatty

pyjulia_attrkind(::Val{:isatty}, ::Type{T}) where {T<:IO} =
    (T <: Base.TTY) ? :method :
    :method

pyjulia_attrdef(::Val{:isatty}, ::Type{T}) where {T<:IO} =
    (T <: Base.TTY) ? pyjulia_attrdef(Val(:isatty), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:isatty), T, IO, Val(2))

const _pyjulia_implmethod_isatty_1_1 = o -> unsafe_pytrue()
function pyjulia_implmethod_isatty_1_1(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_isatty_1_1(x1))
    return r
end

pyjulia_attrdef(::Val{:isatty}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "isatty",
    meth = @cfunction(pyjulia_implmethod_isatty_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)

const _pyjulia_implmethod_isatty_1_2 = o -> unsafe_pyfalse()
function pyjulia_implmethod_isatty_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_isatty_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:isatty}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "isatty",
    meth = @cfunction(pyjulia_implmethod_isatty_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### IO.truncate

pyjulia_attrkind(::Val{:truncate}, ::Type{T}) where {T<:IO} =
    (hasmethod(truncate, Tuple{T,Int})) ? :method :
    :method

pyjulia_attrdef(::Val{:truncate}, ::Type{T}) where {T<:IO} =
    (hasmethod(truncate, Tuple{T,Int})) ? pyjulia_attrdef(Val(:truncate), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:truncate), T, IO, Val(2))

const _pyjulia_implmethod_truncate_1_1 = function (o, _a)
    n, = @safe @unsafe_pyargparse _a (size::Union{Int,Nothing}=nothing,)
    n = n===nothing ? position(o) : n
    truncate(o, n)
    return unsafe_pynone()
    @label error
    return PYNULL
end
function pyjulia_implmethod_truncate_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_truncate_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:truncate}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "truncate",
    meth = @cfunction(pyjulia_implmethod_truncate_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)

const _pyjulia_implmethod_truncate_1_2 = (o, a) -> (pyerr_set_UnsupportedOperation("truncate"); PYNULL)
function pyjulia_implmethod_truncate_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_truncate_1_2(x1, x2))
    return r
end

pyjulia_attrdef(::Val{:truncate}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "truncate",
    meth = @cfunction(pyjulia_implmethod_truncate_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)


### IO.closed

pyjulia_attrkind(::Val{:closed}, ::Type{T}) where {T<:IO} =
    (hasmethod(isopen, Tuple{T})) ? :property :
    :property

pyjulia_attrdef(::Val{:closed}, ::Type{T}) where {T<:IO} =
    (hasmethod(isopen, Tuple{T})) ? pyjulia_attrdef(Val(:closed), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:closed), T, IO, Val(2))

const _pyjulia_implgetter_closed_1_1 = o -> unsafe_pybool(!isopen(o))
function pyjulia_implgetter_closed_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implgetter_closed_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:closed}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "closed",
    get = @cfunction(pyjulia_implgetter_closed_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, Ptr{Cvoid})),
)

const _pyjulia_implgetter_closed_1_2 = o -> (pyerror_set_IOUnsupportedOperation("closed"); PYNULL)
function pyjulia_implgetter_closed_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implgetter_closed_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:closed}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "closed",
    get = @cfunction(pyjulia_implgetter_closed_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, Ptr{Cvoid})),
)


### IO.fileno

pyjulia_attrkind(::Val{:fileno}, ::Type{T}) where {T<:IO} =
    (hasmethod(fd, Tuple{T})) ? :method :
    :method

pyjulia_attrdef(::Val{:fileno}, ::Type{T}) where {T<:IO} =
    (hasmethod(fd, Tuple{T})) ? pyjulia_attrdef(Val(:fileno), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:fileno), T, IO, Val(2))

const _pyjulia_implmethod_fileno_1_1 = o -> unsafe_pyint(fd(o))
function pyjulia_implmethod_fileno_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_fileno_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:fileno}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "fileno",
    meth = @cfunction(pyjulia_implmethod_fileno_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)

const _pyjulia_implmethod_fileno_1_2 = o -> (pyerror_set_IOUnsupportedOperation("fileno"); PYNULL)
function pyjulia_implmethod_fileno_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_fileno_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:fileno}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "fileno",
    meth = @cfunction(pyjulia_implmethod_fileno_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### IO.writable

pyjulia_attrkind(::Val{:writable}, ::Type{T}) where {T<:IO} =
    (hasmethod(iswritable, Tuple{T})) ? :method :
    :method

pyjulia_attrdef(::Val{:writable}, ::Type{T}) where {T<:IO} =
    (hasmethod(iswritable, Tuple{T})) ? pyjulia_attrdef(Val(:writable), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:writable), T, IO, Val(2))

const _pyjulia_implmethod_writable_1_1 = o -> unsafe_pybool(iswritable(o))
function pyjulia_implmethod_writable_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_writable_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:writable}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "writable",
    meth = @cfunction(pyjulia_implmethod_writable_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)

const _pyjulia_implmethod_writable_1_2 = o -> (pyerror_set_IOUnsupportedOperation("writable"); PYNULL)
function pyjulia_implmethod_writable_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_writable_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:writable}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "writable",
    meth = @cfunction(pyjulia_implmethod_writable_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### IO.tell

pyjulia_attrkind(::Val{:tell}, ::Type{T}) where {T<:IO} =
    (hasmethod(position, Tuple{T})) ? :method :
    :method

pyjulia_attrdef(::Val{:tell}, ::Type{T}) where {T<:IO} =
    (hasmethod(position, Tuple{T})) ? pyjulia_attrdef(Val(:tell), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:tell), T, IO, Val(2))

const _pyjulia_implmethod_tell_1_1 = o -> unsafe_pyint(position(o))
function pyjulia_implmethod_tell_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_tell_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:tell}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "tell",
    meth = @cfunction(pyjulia_implmethod_tell_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)

const _pyjulia_implmethod_tell_1_2 = o -> (pyerror_set_IOUnsupportedOperation("tell"); PYNULL)
function pyjulia_implmethod_tell_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_tell_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:tell}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "tell",
    meth = @cfunction(pyjulia_implmethod_tell_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### IO.flush

pyjulia_attrkind(::Val{:flush}, ::Type{T}) where {T<:IO} =
    (hasmethod(flush, Tuple{T})) ? :method :
    :method

pyjulia_attrdef(::Val{:flush}, ::Type{T}) where {T<:IO} =
    (hasmethod(flush, Tuple{T})) ? pyjulia_attrdef(Val(:flush), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:flush), T, IO, Val(2))

const _pyjulia_implmethod_flush_1_1 = o -> (flush(o); unsafe_pynone())
function pyjulia_implmethod_flush_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_flush_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:flush}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "flush",
    meth = @cfunction(pyjulia_implmethod_flush_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)

const _pyjulia_implmethod_flush_1_2 = o -> (pyerror_set_IOUnsupportedOperation("flush"); PYNULL)
function pyjulia_implmethod_flush_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_flush_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:flush}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "flush",
    meth = @cfunction(pyjulia_implmethod_flush_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### IO.readable

pyjulia_attrkind(::Val{:readable}, ::Type{T}) where {T<:IO} =
    (hasmethod(isreadable, Tuple{T})) ? :method :
    :method

pyjulia_attrdef(::Val{:readable}, ::Type{T}) where {T<:IO} =
    (hasmethod(isreadable, Tuple{T})) ? pyjulia_attrdef(Val(:readable), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:readable), T, IO, Val(2))

const _pyjulia_implmethod_readable_1_1 = o -> unsafe_pybool(isreadable(o))
function pyjulia_implmethod_readable_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_readable_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:readable}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "readable",
    meth = @cfunction(pyjulia_implmethod_readable_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)

const _pyjulia_implmethod_readable_1_2 = o -> (pyerror_set_IOUnsupportedOperation("readable"); PYNULL)
function pyjulia_implmethod_readable_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_readable_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:readable}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "readable",
    meth = @cfunction(pyjulia_implmethod_readable_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### IO.seekable

pyjulia_attrkind(::Val{:seekable}, ::Type{T}) where {T<:IO} =
    (hasmethod(position, Tuple{T}) && hasmethod(seek, Tuple{T,Int}) && hasmethod(seekstart, Tuple{T}) && hasmethod(seekend, Tuple{T})) ? :method :
    :method

pyjulia_attrdef(::Val{:seekable}, ::Type{T}) where {T<:IO} =
    (hasmethod(position, Tuple{T}) && hasmethod(seek, Tuple{T,Int}) && hasmethod(seekstart, Tuple{T}) && hasmethod(seekend, Tuple{T})) ? pyjulia_attrdef(Val(:seekable), T, IO, Val(1)) :
    pyjulia_attrdef(Val(:seekable), T, IO, Val(2))

const _pyjulia_implmethod_seekable_1_1 = o -> unsafe_pytrue()
function pyjulia_implmethod_seekable_1_1(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_seekable_1_1(x1))
    return r
end

pyjulia_attrdef(::Val{:seekable}, ::Type{T}, ::Type{IO}, ::Val{1}) where {T<:IO} = (
    name = "seekable",
    meth = @cfunction(pyjulia_implmethod_seekable_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)

const _pyjulia_implmethod_seekable_1_2 = o -> unsafe_pyfalse()
function pyjulia_implmethod_seekable_1_2(x1, x2)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod_seekable_1_2(x1))
    return r
end

pyjulia_attrdef(::Val{:seekable}, ::Type{T}, ::Type{IO}, ::Val{2}) where {T<:IO} = (
    name = "seekable",
    meth = @cfunction(pyjulia_implmethod_seekable_1_2, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AbstractArray.__setitem__

pyjulia_attrkind(::Val{:__setitem__}, ::Type{T}) where {T<:AbstractArray} =
    :special

pyjulia_attrdef(::Val{:__setitem__}, ::Type{T}) where {T<:AbstractArray} =
    pyjulia_attrdef(Val(:__setitem__), T, AbstractArray, Val(1))

const _pyjulia_implmethod___setitem___1_1 = function (o, ko, vo)
    k = @safe unsafe_pyconvertarrayindices(o, ko)
    if !isa(k, Tuple{Vararg{Int}})
        pyerror_set_TypeError("can only set single array items")
        return -1
    end
    v = @safe unsafe_pyconvertvalue(o, vo)
    if checkbounds(Bool, o, k...)
        o[k...] = v
        return 0
    else
        pyerror_set_IndexError("array index out of bounds")
    end
    @label error
    return -1
end
function pyjulia_implmethod___setitem___1_1(y1, y2, y3)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    x3 = pyjulia_argval(y3)
    try
        r::Cint = pyjulia_retval(_pyjulia_implmethod___setitem___1_1(x1, x2, x3))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return (zero(Cint) - one(Cint))
    end
end

pyjulia_attrdef(::Val{:__setitem__}, ::Type{T}, ::Type{AbstractArray}, ::Val{1}) where {T<:AbstractArray} =
    @cfunction(pyjulia_implmethod___setitem___1_1, Cint, (Ptr{CPyJuliaObject{T}}, PyPtr, PyPtr))


### AbstractArray.shape

pyjulia_attrkind(::Val{:shape}, ::Type{T}) where {T<:AbstractArray} =
    :property

pyjulia_attrdef(::Val{:shape}, ::Type{T}) where {T<:AbstractArray} =
    pyjulia_attrdef(Val(:shape), T, AbstractArray, Val(1))

const _pyjulia_implgetter_shape_1_1 = o -> unsafe_pytuple_fromiter(size(o))
function pyjulia_implgetter_shape_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implgetter_shape_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:shape}, ::Type{T}, ::Type{AbstractArray}, ::Val{1}) where {T<:AbstractArray} = (
    name = "shape",
    get = @cfunction(pyjulia_implgetter_shape_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, Ptr{Cvoid})),
)


### AbstractArray.__getitem__

pyjulia_attrkind(::Val{:__getitem__}, ::Type{T}) where {T<:AbstractArray} =
    :special

pyjulia_attrdef(::Val{:__getitem__}, ::Type{T}) where {T<:AbstractArray} =
    pyjulia_attrdef(Val(:__getitem__), T, AbstractArray, Val(1))

const _pyjulia_implmethod___getitem___1_1 = function (o, ko)
    k = @safe unsafe_pyconvertarrayindices(o, ko)
    if checkbounds(Bool, o, k...)
        return unsafe_pyobj(o[k...])
    else
        pyerror_set_IndexError("array index out of bounds")
    end
    @label error
    return PYNULL
end
function pyjulia_implmethod___getitem___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___getitem___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__getitem__}, ::Type{T}, ::Type{AbstractArray}, ::Val{1}) where {T<:AbstractArray} =
    @cfunction(pyjulia_implmethod___getitem___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr))


### Real.__float__

pyjulia_attrkind(::Val{:__float__}, ::Type{T}) where {T<:Real} =
    :special

pyjulia_attrdef(::Val{:__float__}, ::Type{T}) where {T<:Real} =
    pyjulia_attrdef(Val(:__float__), T, Real, Val(1))

const _pyjulia_implmethod___float___1_1 = o -> unsafe_pyfloat(o)
function pyjulia_implmethod___float___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___float___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__float__}, ::Type{T}, ::Type{Real}, ::Val{1}) where {T<:Real} =
    @cfunction(pyjulia_implmethod___float___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Real.__floor__

pyjulia_attrkind(::Val{:__floor__}, ::Type{T}) where {T<:Real} =
    (hasmethod(floor, Tuple{Type{Integer}, T})) ? :method :
    invoke(pyjulia_attrkind, Tuple{Val{:__floor__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__floor__), T)

pyjulia_attrdef(::Val{:__floor__}, ::Type{T}) where {T<:Real} =
    (hasmethod(floor, Tuple{Type{Integer}, T})) ? pyjulia_attrdef(Val(:__floor__), T, Real, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__floor__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__floor__), T)

const _pyjulia_implmethod___floor___1_1 = o -> unsafe_pyint(floor(Integer, o))
function pyjulia_implmethod___floor___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___floor___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__floor__}, ::Type{T}, ::Type{Real}, ::Val{1}) where {T<:Real} = (
    name = "__floor__",
    meth = @cfunction(pyjulia_implmethod___floor___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### Real.__ceil__

pyjulia_attrkind(::Val{:__ceil__}, ::Type{T}) where {T<:Real} =
    (hasmethod(ceil, Tuple{Type{Integer}, T})) ? :method :
    invoke(pyjulia_attrkind, Tuple{Val{:__ceil__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__ceil__), T)

pyjulia_attrdef(::Val{:__ceil__}, ::Type{T}) where {T<:Real} =
    (hasmethod(ceil, Tuple{Type{Integer}, T})) ? pyjulia_attrdef(Val(:__ceil__), T, Real, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__ceil__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__ceil__), T)

const _pyjulia_implmethod___ceil___1_1 = o -> unsafe_pyint(ceil(Integer, o))
function pyjulia_implmethod___ceil___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___ceil___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__ceil__}, ::Type{T}, ::Type{Real}, ::Val{1}) where {T<:Real} = (
    name = "__ceil__",
    meth = @cfunction(pyjulia_implmethod___ceil___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### Real.__round__

pyjulia_attrkind(::Val{:__round__}, ::Type{T}) where {T<:Real} =
    (hasmethod(round, Tuple{Type{Integer}, T}) && hasmethod(round, Tuple{T})) ? :method :
    invoke(pyjulia_attrkind, Tuple{Val{:__round__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__round__), T)

pyjulia_attrdef(::Val{:__round__}, ::Type{T}) where {T<:Real} =
    (hasmethod(round, Tuple{Type{Integer}, T}) && hasmethod(round, Tuple{T})) ? pyjulia_attrdef(Val(:__round__), T, Real, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__round__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__round__), T)

const _pyjulia_implmethod___round___1_1 = function (o, _a)
    d, = @safe @unsafe_pyargparse _a (digits::Union{Int,Nothing}=nothing,)
    if d === nothing
        return unsafe_pyint(round(Integer, o))
    else
        return unsafe_pyjulia(round(o, digits=d))
    end
    @label error
    return PYNULL
end
function pyjulia_implmethod___round___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___round___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__round__}, ::Type{T}, ::Type{Real}, ::Val{1}) where {T<:Real} = (
    name = "__round__",
    meth = @cfunction(pyjulia_implmethod___round___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)


### Real.__int__

pyjulia_attrkind(::Val{:__int__}, ::Type{T}) where {T<:Real} =
    (hasmethod(round, Tuple{Type{Integer}, T})) ? :special :
    invoke(pyjulia_attrkind, Tuple{Val{:__int__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__int__), T)

pyjulia_attrdef(::Val{:__int__}, ::Type{T}) where {T<:Real} =
    (hasmethod(round, Tuple{Type{Integer}, T})) ? pyjulia_attrdef(Val(:__int__), T, Real, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__int__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__int__), T)

const _pyjulia_implmethod___int___1_1 = o -> unsafe_pyint(round(Integer, o))
function pyjulia_implmethod___int___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___int___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__int__}, ::Type{T}, ::Type{Real}, ::Val{1}) where {T<:Real} =
    @cfunction(pyjulia_implmethod___int___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Real.__trunc__

pyjulia_attrkind(::Val{:__trunc__}, ::Type{T}) where {T<:Real} =
    (hasmethod(trunc, Tuple{Type{Integer}, T})) ? :method :
    invoke(pyjulia_attrkind, Tuple{Val{:__trunc__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__trunc__), T)

pyjulia_attrdef(::Val{:__trunc__}, ::Type{T}) where {T<:Real} =
    (hasmethod(trunc, Tuple{Type{Integer}, T})) ? pyjulia_attrdef(Val(:__trunc__), T, Real, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__trunc__}, Type{_T}} where {_T<:supertype(Real)}, Val(:__trunc__), T)

const _pyjulia_implmethod___trunc___1_1 = o -> unsafe_pyint(trunc(Integer, o))
function pyjulia_implmethod___trunc___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___trunc___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__trunc__}, ::Type{T}, ::Type{Real}, ::Val{1}) where {T<:Real} = (
    name = "__trunc__",
    meth = @cfunction(pyjulia_implmethod___trunc___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AsPyRawIO.write

pyjulia_attrkind(::Val{:write}, ::Type{T}) where {T<:AsPyRawIO} =
    :method

pyjulia_attrdef(::Val{:write}, ::Type{T}) where {T<:AsPyRawIO} =
    pyjulia_attrdef(Val(:write), T, AsPyRawIO, Val(1))

const _pyjulia_implmethod_write_1_1 = function(o, b)
    buf = @safe unsafe_PyBuffer(b, CPyBUF_SIMPLE)
    arr = unsafe_wrap(Array, Ptr{UInt8}(buf.buf), buf.len)
    num = write(o, arr)
    return unsafe_pyint(num)
    @label error
    return PYNULL
end
function pyjulia_implmethod_write_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_write_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:write}, ::Type{T}, ::Type{AsPyRawIO}, ::Val{1}) where {T<:AsPyRawIO} = (
    name = "write",
    meth = @cfunction(pyjulia_implmethod_write_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AsPyRawIO.readinto

pyjulia_attrkind(::Val{:readinto}, ::Type{T}) where {T<:AsPyRawIO} =
    :method

pyjulia_attrdef(::Val{:readinto}, ::Type{T}) where {T<:AsPyRawIO} =
    pyjulia_attrdef(Val(:readinto), T, AsPyRawIO, Val(1))

const _pyjulia_implmethod_readinto_1_1 = function (o, b)
    buf = @safe unsafe_PyBuffer(b, CPyBUF_WRITABLE)
    arr = unsafe_wrap(Array, Ptr{UInt8}(buf.buf), buf.len)
    num = readbytes!(o, arr)
    return unsafe_pyint(num)
    @label error
    return PYNULL
end
function pyjulia_implmethod_readinto_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_readinto_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:readinto}, ::Type{T}, ::Type{AsPyRawIO}, ::Val{1}) where {T<:AsPyRawIO} = (
    name = "readinto",
    meth = @cfunction(pyjulia_implmethod_readinto_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AsPyRawIO.readall

pyjulia_attrkind(::Val{:readall}, ::Type{T}) where {T<:AsPyRawIO} =
    :method

pyjulia_attrdef(::Val{:readall}, ::Type{T}) where {T<:AsPyRawIO} =
    pyjulia_attrdef(Val(:readall), T, AsPyRawIO, Val(1))

const _pyjulia_implmethod_readall_1_1 = o -> unsafe_pybytes(read(o))
function pyjulia_implmethod_readall_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_readall_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:readall}, ::Type{T}, ::Type{AsPyRawIO}, ::Val{1}) where {T<:AsPyRawIO} = (
    name = "readall",
    meth = @cfunction(pyjulia_implmethod_readall_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AsPyRawIO.read

pyjulia_attrkind(::Val{:read}, ::Type{T}) where {T<:AsPyRawIO} =
    :method

pyjulia_attrdef(::Val{:read}, ::Type{T}) where {T<:AsPyRawIO} =
    pyjulia_attrdef(Val(:read), T, AsPyRawIO, Val(1))

const _pyjulia_implmethod_read_1_1 = function(o, _a)
    n, = @safe @unsafe_pyargparse _a (size::Union{Int,Nothing}=nothing,)
    if n===nothing || n<0
        x = read(o)
    else
        x = read(o, n)
    end
    return unsafe_pybytes(x)
    @label error
    return PYNULL
end
function pyjulia_implmethod_read_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_read_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:read}, ::Type{T}, ::Type{AsPyRawIO}, ::Val{1}) where {T<:AsPyRawIO} = (
    name = "read",
    meth = @cfunction(pyjulia_implmethod_read_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)


### Iterator.__next__

pyjulia_attrkind(::Val{:__next__}, ::Type{T}) where {T<:Iterator} =
    :special

pyjulia_attrdef(::Val{:__next__}, ::Type{T}) where {T<:Iterator} =
    pyjulia_attrdef(Val(:__next__), T, Iterator, Val(1))

const _pyjulia_implmethod___next___1_1 = function (o)
    source = o.source
    state = o.state
    x = state === nothing ? iterate(source) : iterate(source, something(state))
    if x === nothing
        pyerror_set_StopIteration()
        return PYNULL
    else
        val, state = x
        o.state = Some(state)
        return unsafe_pyobj(val)
    end
end
function pyjulia_implmethod___next___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___next___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__next__}, ::Type{T}, ::Type{Iterator}, ::Val{1}) where {T<:Iterator} =
    @cfunction(pyjulia_implmethod___next___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Iterator.__iter__

pyjulia_attrkind(::Val{:__iter__}, ::Type{T}) where {T<:Iterator} =
    :special

pyjulia_attrdef(::Val{:__iter__}, ::Type{T}) where {T<:Iterator} =
    pyjulia_attrdef(Val(:__iter__), T, Iterator, Val(1))

const _pyjulia_implmethod___iter___1_1 = o -> incref!(PyBorrowedRef(o))
function pyjulia_implmethod___iter___1_1(x1)
    r::PyPtr = pyjulia_retval(_pyjulia_implmethod___iter___1_1(x1))
    return r
end

pyjulia_attrdef(::Val{:__iter__}, ::Type{T}, ::Type{Iterator}, ::Val{1}) where {T<:Iterator} =
    @cfunction(pyjulia_implmethod___iter___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### AbstractDict.items

pyjulia_attrkind(::Val{:items}, ::Type{T}) where {T<:AbstractDict} =
    :method

pyjulia_attrdef(::Val{:items}, ::Type{T}) where {T<:AbstractDict} =
    pyjulia_attrdef(Val(:items), T, AbstractDict, Val(1))

const _pyjulia_implmethod_items_1_1 = o -> unsafe_pyjulia(PairSet(o))
function pyjulia_implmethod_items_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_items_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:items}, ::Type{T}, ::Type{AbstractDict}, ::Val{1}) where {T<:AbstractDict} = (
    name = "items",
    meth = @cfunction(pyjulia_implmethod_items_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AbstractDict.__iter__

pyjulia_attrkind(::Val{:__iter__}, ::Type{T}) where {T<:AbstractDict} =
    :special

pyjulia_attrdef(::Val{:__iter__}, ::Type{T}) where {T<:AbstractDict} =
    pyjulia_attrdef(Val(:__iter__), T, AbstractDict, Val(1))

const _pyjulia_implmethod___iter___2_1 = o -> unsafe_pyjulia(Iterator(keys(o)))
function pyjulia_implmethod___iter___2_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___iter___2_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__iter__}, ::Type{T}, ::Type{AbstractDict}, ::Val{1}) where {T<:AbstractDict} =
    @cfunction(pyjulia_implmethod___iter___2_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### AbstractDict.keys

pyjulia_attrkind(::Val{:keys}, ::Type{T}) where {T<:AbstractDict} =
    :method

pyjulia_attrdef(::Val{:keys}, ::Type{T}) where {T<:AbstractDict} =
    pyjulia_attrdef(Val(:keys), T, AbstractDict, Val(1))

const _pyjulia_implmethod_keys_1_1 = o -> unsafe_pyjulia(keys(o))
function pyjulia_implmethod_keys_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_keys_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:keys}, ::Type{T}, ::Type{AbstractDict}, ::Val{1}) where {T<:AbstractDict} = (
    name = "keys",
    meth = @cfunction(pyjulia_implmethod_keys_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AbstractDict.values

pyjulia_attrkind(::Val{:values}, ::Type{T}) where {T<:AbstractDict} =
    :method

pyjulia_attrdef(::Val{:values}, ::Type{T}) where {T<:AbstractDict} =
    pyjulia_attrdef(Val(:values), T, AbstractDict, Val(1))

const _pyjulia_implmethod_values_1_1 = o -> unsafe_pyjulia(values(o))
function pyjulia_implmethod_values_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_values_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:values}, ::Type{T}, ::Type{AbstractDict}, ::Val{1}) where {T<:AbstractDict} = (
    name = "values",
    meth = @cfunction(pyjulia_implmethod_values_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AbstractDict.__contains__

pyjulia_attrkind(::Val{:__contains__}, ::Type{T}) where {T<:AbstractDict} =
    :special

pyjulia_attrdef(::Val{:__contains__}, ::Type{T}) where {T<:AbstractDict} =
    pyjulia_attrdef(Val(:__contains__), T, AbstractDict, Val(1))

const _pyjulia_implmethod___contains___1_1 = function (o, ko)
    k = unsafe_pytryconvertkey(o, ko)
    if k.iserr
        return -1
    elseif k.isnothing
        return 0
    elseif haskey(o, k.value)
        return 1
    else
        return 0
    end
end
function pyjulia_implmethod___contains___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::Cint = pyjulia_retval(_pyjulia_implmethod___contains___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return (zero(Cint) - one(Cint))
    end
end

pyjulia_attrdef(::Val{:__contains__}, ::Type{T}, ::Type{AbstractDict}, ::Val{1}) where {T<:AbstractDict} =
    @cfunction(pyjulia_implmethod___contains___1_1, Cint, (Ptr{CPyJuliaObject{T}}, PyPtr))


### AbstractDict.get

pyjulia_attrkind(::Val{:get}, ::Type{T}) where {T<:AbstractDict} =
    :method

pyjulia_attrdef(::Val{:get}, ::Type{T}) where {T<:AbstractDict} =
    pyjulia_attrdef(Val(:get), T, AbstractDict, Val(1))

const _pyjulia_implmethod_get_1_1 = function (o, _a)
    ko, d = @safe @unsafe_pyargparse _a (key::PyObject, default::PyObject=(@safe unsafe_pynone()))
    k = unsafe_pytryconvertkey(o, ko)
    if k.iserr
        @label error
        return PYNULL
    elseif k.isnothing
        return d
    else
        return unsafe_pyobj(get(o, k.value, d))
    end
end
function pyjulia_implmethod_get_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_get_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:get}, ::Type{T}, ::Type{AbstractDict}, ::Val{1}) where {T<:AbstractDict} = (
    name = "get",
    meth = @cfunction(pyjulia_implmethod_get_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)


### StridedArray.__array_interface__

pyjulia_attrkind(::Val{:__array_interface__}, ::Type{T}) where {T<:StridedArray} =
    :property

pyjulia_attrdef(::Val{:__array_interface__}, ::Type{T}) where {T<:StridedArray} =
    pyjulia_attrdef(Val(:__array_interface__), T, StridedArray, Val(1))

const _pyjulia_implgetter___array_interface___1_1 = function (o)
    d = Dict{String, PyObject}()
    d["shape"] = @safe unsafe_pytuple_fromiter(size(o))
    x, y, elsize = numpy_typestr_descr(eltype(o))
    isnull(x) && @goto error
    d["typestr"] = x
    isnull(y) || (d["descr"] = y)
    d["data"] = @safe unsafe_pytuple_fromiter((convert(Integer, Base.unsafe_convert(Ptr{eltype(o)}, o)), isimmutable(o)))
    d["strides"] = @safe unsafe_pytuple_fromiter(elsize .* strides(o))
    d["version"] = @safe unsafe_pyint(3)
    return unsafe_pydict_fromstringpairs(d)
    @label error
    return PYNULL
end
function pyjulia_implgetter___array_interface___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implgetter___array_interface___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__array_interface__}, ::Type{T}, ::Type{StridedArray}, ::Val{1}) where {T<:StridedArray} = (
    name = "__array_interface__",
    get = @cfunction(pyjulia_implgetter___array_interface___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, Ptr{Cvoid})),
)


### AbstractVector.reverse

pyjulia_attrkind(::Val{:reverse}, ::Type{T}) where {T<:AbstractVector} =
    (hasmethod(reverse!, Tuple{T})) ? :method :
    invoke(pyjulia_attrkind, Tuple{Val{:reverse}, Type{_T}} where {_T<:supertype(AbstractVector)}, Val(:reverse), T)

pyjulia_attrdef(::Val{:reverse}, ::Type{T}) where {T<:AbstractVector} =
    (hasmethod(reverse!, Tuple{T})) ? pyjulia_attrdef(Val(:reverse), T, AbstractVector, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:reverse}, Type{_T}} where {_T<:supertype(AbstractVector)}, Val(:reverse), T)

const _pyjulia_implmethod_reverse_1_1 = o -> (reverse!(o); unsafe_pynone())
function pyjulia_implmethod_reverse_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_reverse_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:reverse}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "reverse",
    meth = @cfunction(pyjulia_implmethod_reverse_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AbstractVector.pop

pyjulia_attrkind(::Val{:pop}, ::Type{T}) where {T<:AbstractVector} =
    :method

pyjulia_attrdef(::Val{:pop}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:pop), T, AbstractVector, Val(1))

const _pyjulia_implmethod_pop_1_1 = function (o, _a)
    i, = @safe @unsafe_pyargparse _a (i::Int=-1,)
    j = i < 0 ? lastindex(o)+i+1 : firstindex(o)+i
    if isempty(o)
        pyerror_set_IndexError("pop from empty vector")
        @goto error
    elseif checkbounds(Bool, o, j)
        v = o[j]
        deleteat!(o, j)
    else
        pyerror_set_IndexError("vector index out of bounds")
        @goto error
    end
    return unsafe_pyobj(v)
    @label error
    return PYNULL
end
function pyjulia_implmethod_pop_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_pop_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:pop}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "pop",
    meth = @cfunction(pyjulia_implmethod_pop_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)


### AbstractVector.remove

pyjulia_attrkind(::Val{:remove}, ::Type{T}) where {T<:AbstractVector} =
    :method

pyjulia_attrdef(::Val{:remove}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:remove), T, AbstractVector, Val(1))

const _pyjulia_implmethod_remove_1_1 = function (o, vo)
    v = unsafe_pytryconvertvalue(o, vo)
    v.iserr && return PYNULL
    if !v.isnothing
        i = findfirst(==(v.value), o)
        if i !== nothing
            deleteat!(o, i)
            return unsafe_pynone()
        end
    end
    pyerror_set_ValueError("value not found")
    return PYNULL
end
function pyjulia_implmethod_remove_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_remove_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:remove}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "remove",
    meth = @cfunction(pyjulia_implmethod_remove_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AbstractVector.extend

pyjulia_attrkind(::Val{:extend}, ::Type{T}) where {T<:AbstractVector} =
    :method

pyjulia_attrdef(::Val{:extend}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:extend), T, AbstractVector, Val(1))

const _pyjulia_implmethod_extend_1_1 = function (o, vs)
    vi = @safe unsafe_pyiter(vs)
    while true
        vo = unsafe_pyiter_next(vi)
        if !isnull(vo)
            v = @safe unsafe_pyconvertvalue(o, vo)
            push!(o, v)
        elseif pyerror_occurred()
            return PYNULL
        else
            break
        end
    end
    return unsafe_pynone()
    @label error
    return PYNULL
end
function pyjulia_implmethod_extend_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_extend_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:extend}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "extend",
    meth = @cfunction(pyjulia_implmethod_extend_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AbstractVector.__irepeat__

pyjulia_attrkind(::Val{:__irepeat__}, ::Type{T}) where {T<:AbstractVector} =
    :special

pyjulia_attrdef(::Val{:__irepeat__}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:__irepeat__), T, AbstractVector, Val(1))

const _pyjulia_implmethod___irepeat___1_1 = function(_o, n)
    o = _unsafe_pyjulia_getvalue(_o)
    if n ≤ 0
        empty!(o)
    elseif n > 1
        len = length(o)
        for i in (len+1):(n*len)
            push!(o, @inbounds(o[i-len]))
        end
    end
    return unsafe_pyobj(PyRef(_o, true))
    @label error
    return PYNULL
end
function pyjulia_implmethod___irepeat___1_1(x1, x2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___irepeat___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__irepeat__}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} =
    @cfunction(pyjulia_implmethod___irepeat___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, CPy_ssize_t))


### AbstractVector.count

pyjulia_attrkind(::Val{:count}, ::Type{T}) where {T<:AbstractVector} =
    :method

pyjulia_attrdef(::Val{:count}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:count), T, AbstractVector, Val(1))

const _pyjulia_implmethod_count_1_1 = function(o, vo)
    v = unsafe_pytryconvertvalue(o, vo)
    if v.iserr
        return PYNULL
    elseif v.isnothing
        n = 0
    else
        n = count(==(v.value), o)
    end
    return unsafe_pyint(n)
end
function pyjulia_implmethod_count_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_count_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:count}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "count",
    meth = @cfunction(pyjulia_implmethod_count_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AbstractVector.__repeat__

pyjulia_attrkind(::Val{:__repeat__}, ::Type{T}) where {T<:AbstractVector} =
    :special

pyjulia_attrdef(::Val{:__repeat__}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:__repeat__), T, AbstractVector, Val(1))

const _pyjulia_implmethod___repeat___1_1 = (o, n) -> unsafe_pyjulia(repeat(o, max(0, n)))

function pyjulia_implmethod___repeat___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___repeat___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__repeat__}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} =
    @cfunction(pyjulia_implmethod___repeat___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, CPy_ssize_t))


### AbstractVector.__iconcat__

pyjulia_attrkind(::Val{:__iconcat__}, ::Type{T}) where {T<:AbstractVector} =
    :special

pyjulia_attrdef(::Val{:__iconcat__}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:__iconcat__), T, AbstractVector, Val(1))

const _pyjulia_implmethod___iconcat___1_1 = function (_o, _vs)
    o = _unsafe_pyjulia_getvalue(_o)
    vs = PyBorrowedRef(_vs)
    vi = @safe unsafe_pyiter(vs)
    while true
        vo = unsafe_pyiter_next(vi)
        if !isnull(vo)
            v = @safe unsafe_pyconvertvalue(o, vo)
            push!(o, v)
        elseif pyerror_occurred()
            return PYNULL
        else
            break
        end
    end
    return unsafe_pyobj(PyRef(_o, true))
    @label error
    return PYNULL
end
function pyjulia_implmethod___iconcat___1_1(x1, x2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___iconcat___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__iconcat__}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} =
    @cfunction(pyjulia_implmethod___iconcat___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr))


### AbstractVector.__getitem_int__

pyjulia_attrkind(::Val{:__getitem_int__}, ::Type{T}) where {T<:AbstractVector} =
    :special

pyjulia_attrdef(::Val{:__getitem_int__}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:__getitem_int__), T, AbstractVector, Val(1))

const _pyjulia_implmethod___getitem_int___1_1 = (o,i) -> unsafe_pyobj(getindex(o, i+firstindex(o)))
function pyjulia_implmethod___getitem_int___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___getitem_int___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__getitem_int__}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} =
    @cfunction(pyjulia_implmethod___getitem_int___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, CPy_ssize_t))


### AbstractVector.index

pyjulia_attrkind(::Val{:index}, ::Type{T}) where {T<:AbstractVector} =
    :method

pyjulia_attrdef(::Val{:index}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:index), T, AbstractVector, Val(1))

const _pyjulia_implmethod_index_1_1 = function(o, vo)
    v = unsafe_pytryconvertvalue(o, vo)
    v.iserr && return PYNULL
    if !v.isnothing
        i = findfirst(==(v.value), o)
        i === nothing || return unsafe_pyint(i-firstindex(o))
    end
    pyerror_set_ValueError("value not found")
    return PYNULL
end
function pyjulia_implmethod_index_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_index_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:index}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "index",
    meth = @cfunction(pyjulia_implmethod_index_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AbstractVector.__reversed__

pyjulia_attrkind(::Val{:__reversed__}, ::Type{T}) where {T<:AbstractVector} =
    (hasmethod(reverse, Tuple{T})) ? :method :
    invoke(pyjulia_attrkind, Tuple{Val{:__reversed__}, Type{_T}} where {_T<:supertype(AbstractVector)}, Val(:__reversed__), T)

pyjulia_attrdef(::Val{:__reversed__}, ::Type{T}) where {T<:AbstractVector} =
    (hasmethod(reverse, Tuple{T})) ? pyjulia_attrdef(Val(:__reversed__), T, AbstractVector, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__reversed__}, Type{_T}} where {_T<:supertype(AbstractVector)}, Val(:__reversed__), T)

const _pyjulia_implmethod___reversed___1_1 = o -> unsafe_pyjulia(reverse(o))
function pyjulia_implmethod___reversed___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___reversed___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__reversed__}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "__reversed__",
    meth = @cfunction(pyjulia_implmethod___reversed___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AbstractVector.append

pyjulia_attrkind(::Val{:append}, ::Type{T}) where {T<:AbstractVector} =
    :method

pyjulia_attrdef(::Val{:append}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:append), T, AbstractVector, Val(1))

const _pyjulia_implmethod_append_1_1 = function (o, vo)
    v = @safe unsafe_pyconvertvalue(o, vo)
    push!(o, v)
    return unsafe_pynone()
    @label error
    return PYNULL
end
function pyjulia_implmethod_append_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_append_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:append}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "append",
    meth = @cfunction(pyjulia_implmethod_append_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AbstractVector.sort

pyjulia_attrkind(::Val{:sort}, ::Type{T}) where {T<:AbstractVector} =
    (hasmethod(sort!, Tuple{T})) ? :method :
    invoke(pyjulia_attrkind, Tuple{Val{:sort}, Type{_T}} where {_T<:supertype(AbstractVector)}, Val(:sort), T)

pyjulia_attrdef(::Val{:sort}, ::Type{T}) where {T<:AbstractVector} =
    (hasmethod(sort!, Tuple{T})) ? pyjulia_attrdef(Val(:sort), T, AbstractVector, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:sort}, Type{_T}} where {_T<:supertype(AbstractVector)}, Val(:sort), T)

const _pyjulia_implmethod_sort_1_1 = o -> (sort!(o); unsafe_pynone())
function pyjulia_implmethod_sort_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_sort_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:sort}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} = (
    name = "sort",
    meth = @cfunction(pyjulia_implmethod_sort_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AbstractVector.__concat__

pyjulia_attrkind(::Val{:__concat__}, ::Type{T}) where {T<:AbstractVector} =
    :special

pyjulia_attrdef(::Val{:__concat__}, ::Type{T}) where {T<:AbstractVector} =
    pyjulia_attrdef(Val(:__concat__), T, AbstractVector, Val(1))

const _pyjulia_implmethod___concat___1_1 = function (o, vs)

    # if vs is a julia wrapped array, use julia concatenation
    if unsafe_pyisjulia(vs)
        jvs = _unsafe_pyjulia_getvalue(vs)
        if jvs isa AbstractVector
            return unsafe_pyjulia([o; jvs])
        end
    end

    # default: aggregate into a list
    r = @safe unsafe_pylist_new()
    for x in o
        @safe unsafe_pylist_append(r, x)
    end
    vi = @safe unsafe_pyiter(vs)
    while true
        vo = unsafe_pyiter_next(vi)
        if !isnull(vo)
            @safe unsafe_pylist_append(r, vo)
        elseif pyerror_occurred()
            return PYNULL
        else
            break
        end
    end
    return r
    @label error
    return PYNULL
end
function pyjulia_implmethod___concat___1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___concat___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__concat__}, ::Type{T}, ::Type{AbstractVector}, ::Val{1}) where {T<:AbstractVector} =
    @cfunction(pyjulia_implmethod___concat___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr))


### AnyComplex.real

pyjulia_attrkind(::Val{:real}, ::Type{T}) where {T<:AnyComplex} =
    :property

pyjulia_attrdef(::Val{:real}, ::Type{T}) where {T<:AnyComplex} =
    pyjulia_attrdef(Val(:real), T, AnyComplex, Val(1))

const _pyjulia_implgetter_real_1_1 = o -> unsafe_pyjulia(real(o))
function pyjulia_implgetter_real_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implgetter_real_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:real}, ::Type{T}, ::Type{AnyComplex}, ::Val{1}) where {T<:AnyComplex} = (
    name = "real",
    get = @cfunction(pyjulia_implgetter_real_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, Ptr{Cvoid})),
)


### AnyComplex.conjugate

pyjulia_attrkind(::Val{:conjugate}, ::Type{T}) where {T<:AnyComplex} =
    :method

pyjulia_attrdef(::Val{:conjugate}, ::Type{T}) where {T<:AnyComplex} =
    pyjulia_attrdef(Val(:conjugate), T, AnyComplex, Val(1))

const _pyjulia_implmethod_conjugate_1_1 = o -> unsafe_pyjulia(conj(o))
function pyjulia_implmethod_conjugate_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_conjugate_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:conjugate}, ::Type{T}, ::Type{AnyComplex}, ::Val{1}) where {T<:AnyComplex} = (
    name = "conjugate",
    meth = @cfunction(pyjulia_implmethod_conjugate_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AnyComplex.imag

pyjulia_attrkind(::Val{:imag}, ::Type{T}) where {T<:AnyComplex} =
    :property

pyjulia_attrdef(::Val{:imag}, ::Type{T}) where {T<:AnyComplex} =
    pyjulia_attrdef(Val(:imag), T, AnyComplex, Val(1))

const _pyjulia_implgetter_imag_1_1 = o -> unsafe_pyjulia(imag(o))
function pyjulia_implgetter_imag_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implgetter_imag_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:imag}, ::Type{T}, ::Type{AnyComplex}, ::Val{1}) where {T<:AnyComplex} = (
    name = "imag",
    get = @cfunction(pyjulia_implgetter_imag_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, Ptr{Cvoid})),
)


### Any.__setitem__

pyjulia_attrkind(::Val{:__setitem__}, ::Type{T}) where {T<:Any} =
    (hasmethod(setindex!, Tuple{T, Union{}, Union{}})) ? :special :
    nothing

pyjulia_attrdef(::Val{:__setitem__}, ::Type{T}) where {T<:Any} =
    (hasmethod(setindex!, Tuple{T, Union{}, Union{}})) ? pyjulia_attrdef(Val(:__setitem__), T, Any, Val(1)) :
    error("no matching attr")

const _pyjulia_implmethod___setitem___2_1 = function (o, _k, _v)
    k = @safe unsafe_pyconvertkey(o, _k)
    v = @safe unsafe_pyconvertvalue(o, k, _v)
    setindex!(o, v, k)
    return 0
    @label error
    return -1
end
function pyjulia_implmethod___setitem___2_1(y1, y2, y3)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    x3 = pyjulia_argval(y3)
    try
        r::Cint = pyjulia_retval(_pyjulia_implmethod___setitem___2_1(x1, x2, x3))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return (zero(Cint) - one(Cint))
    end
end

pyjulia_attrdef(::Val{:__setitem__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___setitem___2_1, Cint, (Ptr{CPyJuliaObject{T}}, PyPtr, PyPtr))


### Any.__iter__

pyjulia_attrkind(::Val{:__iter__}, ::Type{T}) where {T<:Any} =
    (hasmethod(iterate, Tuple{T})) ? :special :
    nothing

pyjulia_attrdef(::Val{:__iter__}, ::Type{T}) where {T<:Any} =
    (hasmethod(iterate, Tuple{T})) ? pyjulia_attrdef(Val(:__iter__), T, Any, Val(1)) :
    error("no matching attr")

const _pyjulia_implmethod___iter___3_1 = o -> unsafe_pyjulia(Iterator(o))
function pyjulia_implmethod___iter___3_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___iter___3_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__iter__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___iter___3_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Any.__contains__

pyjulia_attrkind(::Val{:__contains__}, ::Type{T}) where {T<:Any} =
    (hasmethod(in, Tuple{Union{}, T})) ? :special :
    nothing

pyjulia_attrdef(::Val{:__contains__}, ::Type{T}) where {T<:Any} =
    (hasmethod(in, Tuple{Union{}, T})) ? pyjulia_attrdef(Val(:__contains__), T, Any, Val(1)) :
    error("no matching attr")

const _pyjulia_implmethod___contains___2_1 = function(o, vo)
    v = unsafe_pytryconvertvalue(o, vo)
    if v.iserr
        return -1
    elseif v.isnothing
        return 0
    elseif v.value in o
        return 1
    else
        return 0
    end
end
function pyjulia_implmethod___contains___2_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::Cint = pyjulia_retval(_pyjulia_implmethod___contains___2_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return (zero(Cint) - one(Cint))
    end
end

pyjulia_attrdef(::Val{:__contains__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___contains___2_1, Cint, (Ptr{CPyJuliaObject{T}}, PyPtr))


### Any.__dealloc__

pyjulia_attrkind(::Val{:__dealloc__}, ::Type{T}) where {T<:Any} =
    :special

pyjulia_attrdef(::Val{:__dealloc__}, ::Type{T}) where {T<:Any} =
    pyjulia_attrdef(Val(:__dealloc__), T, Any, Val(1))

const _pyjulia_implmethod___dealloc___1_1 = function (o)
    isnull(uptr(o).weaklist[]) || ccall((:PyObject_ClearWeakRefs, PYLIB), Cvoid, (PyPtr,), o)
    delete!(PYJLGCCACHE, ptr(o))
    nothing
end
function pyjulia_implmethod___dealloc___1_1(x1)
    r::Cvoid = pyjulia_retval(_pyjulia_implmethod___dealloc___1_1(x1))
    return r
end

pyjulia_attrdef(::Val{:__dealloc__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___dealloc___1_1, Cvoid, (Ptr{CPyJuliaObject{T}},))


### Any.__getitem__

pyjulia_attrkind(::Val{:__getitem__}, ::Type{T}) where {T<:Any} =
    (hasmethod(getindex, Tuple{T, Union{}})) ? :special :
    nothing

pyjulia_attrdef(::Val{:__getitem__}, ::Type{T}) where {T<:Any} =
    (hasmethod(getindex, Tuple{T, Union{}})) ? pyjulia_attrdef(Val(:__getitem__), T, Any, Val(1)) :
    error("no matching attr")

const _pyjulia_implmethod___getitem___2_1 = function (o, _k)
    k = @safe unsafe_pyconvertkey(o, _k)
    return unsafe_pyobj(getindex(o, k))
    @label error
    return PYNULL
end
function pyjulia_implmethod___getitem___2_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___getitem___2_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__getitem__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___getitem___2_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr))


### Any.__getattr__

pyjulia_attrkind(::Val{:__getattr__}, ::Type{T}) where {T<:Any} =
    :special

pyjulia_attrdef(::Val{:__getattr__}, ::Type{T}) where {T<:Any} =
    pyjulia_attrdef(Val(:__getattr__), T, Any, Val(1))

const _pyjulia_implmethod___getattr___1_1 = function (__o, __a)
    _o = PyBorrowedRef(__o)
    _a = PyBorrowedRef(__a)
    # generic lookup
    r = unsafe_pygenericgetattr(_o, _a)
    if !isnull(r) || !pyerror_occurred_AttributeError()
        return r
    end
    # julia property?
    o = _unsafe_pyjulia_getvalue(_o)
    a = Symbol(@safe unsafe_pystr_asjuliastring(_a))
    if hasproperty(o, a)
        pyerror_clear()
        return unsafe_pyobj(getproperty(o, a))
    end
    return r
    @label error
    return PYNULL
end
function pyjulia_implmethod___getattr___1_1(x1, x2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___getattr___1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__getattr__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___getattr___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr))


### Any.__dir__

pyjulia_attrkind(::Val{:__dir__}, ::Type{T}) where {T<:Any} =
    :method

pyjulia_attrdef(::Val{:__dir__}, ::Type{T}) where {T<:Any} =
    pyjulia_attrdef(Val(:__dir__), T, Any, Val(1))

const _pyjulia_implmethod___dir___1_1 = function (_o)
    # call the generic __dir__
    obj = @safe unsafe_pyobjecttype()
    dir = @safe unsafe_pygetattr(obj, "__dir__")
    d   = @safe unsafe_pycall(dir, _o)
    # add properties of o
    o = _unsafe_pyjulia_getvalue(_o)
    for a in propertynames(o)
        k = @safe unsafe_pystr(string(a))
        @safe unsafe_pylist_append(d, k)
    end
    return d
    @label error
    return PYNULL
end
function pyjulia_implmethod___dir___1_1(x1, x2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___dir___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__dir__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} = (
    name = "__dir__",
    meth = @cfunction(pyjulia_implmethod___dir___1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### Any.__str__

pyjulia_attrkind(::Val{:__str__}, ::Type{T}) where {T<:Any} =
    :special

pyjulia_attrdef(::Val{:__str__}, ::Type{T}) where {T<:Any} =
    pyjulia_attrdef(Val(:__str__), T, Any, Val(1))

const _pyjulia_implmethod___str___1_1 = o -> unsafe_pystr(string(o))
function pyjulia_implmethod___str___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___str___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__str__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___str___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Any.__repr__

pyjulia_attrkind(::Val{:__repr__}, ::Type{T}) where {T<:Any} =
    :special

pyjulia_attrdef(::Val{:__repr__}, ::Type{T}) where {T<:Any} =
    pyjulia_attrdef(Val(:__repr__), T, Any, Val(1))

const _pyjulia_implmethod___repr___1_1 = o -> unsafe_pystr("<julia $(repr(o))>")
function pyjulia_implmethod___repr___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___repr___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__repr__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___repr___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Any.__len__

pyjulia_attrkind(::Val{:__len__}, ::Type{T}) where {T<:Any} =
    (hasmethod(length, Tuple{T})) ? :special :
    nothing

pyjulia_attrdef(::Val{:__len__}, ::Type{T}) where {T<:Any} =
    (hasmethod(length, Tuple{T})) ? pyjulia_attrdef(Val(:__len__), T, Any, Val(1)) :
    error("no matching attr")

const _pyjulia_implmethod___len___1_1 = length
function pyjulia_implmethod___len___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::CPy_ssize_t = pyjulia_retval(_pyjulia_implmethod___len___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return (zero(CPy_ssize_t) - one(CPy_ssize_t))
    end
end

pyjulia_attrdef(::Val{:__len__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___len___1_1, CPy_ssize_t, (Ptr{CPyJuliaObject{T}},))


### Any.__hash__

pyjulia_attrkind(::Val{:__hash__}, ::Type{T}) where {T<:Any} =
    :special

pyjulia_attrdef(::Val{:__hash__}, ::Type{T}) where {T<:Any} =
    pyjulia_attrdef(Val(:__hash__), T, Any, Val(1))

const _pyjulia_implmethod___hash___1_1 = o -> zero(CPy_hash_t)
function pyjulia_implmethod___hash___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::CPy_hash_t = pyjulia_retval(_pyjulia_implmethod___hash___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return (zero(CPy_hash_t) - one(CPy_hash_t))
    end
end

pyjulia_attrdef(::Val{:__hash__}, ::Type{T}, ::Type{Any}, ::Val{1}) where {T<:Any} =
    @cfunction(pyjulia_implmethod___hash___1_1, CPy_hash_t, (Ptr{CPyJuliaObject{T}},))


### Integer.__index__

pyjulia_attrkind(::Val{:__index__}, ::Type{T}) where {T<:Integer} =
    :special

pyjulia_attrdef(::Val{:__index__}, ::Type{T}) where {T<:Integer} =
    pyjulia_attrdef(Val(:__index__), T, Integer, Val(1))

const _pyjulia_implmethod___index___1_1 = o -> unsafe_pyint(o)
function pyjulia_implmethod___index___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___index___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__index__}, ::Type{T}, ::Type{Integer}, ::Val{1}) where {T<:Integer} =
    @cfunction(pyjulia_implmethod___index___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Integer.__invert__

pyjulia_attrkind(::Val{:__invert__}, ::Type{T}) where {T<:Integer} =
    (hasmethod(~, Tuple{T})) ? :special :
    invoke(pyjulia_attrkind, Tuple{Val{:__invert__}, Type{_T}} where {_T<:supertype(Integer)}, Val(:__invert__), T)

pyjulia_attrdef(::Val{:__invert__}, ::Type{T}) where {T<:Integer} =
    (hasmethod(~, Tuple{T})) ? pyjulia_attrdef(Val(:__invert__), T, Integer, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__invert__}, Type{_T}} where {_T<:supertype(Integer)}, Val(:__invert__), T)

const _pyjulia_implmethod___invert___1_1 = o -> unsafe_pyjulia(~o)
function pyjulia_implmethod___invert___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___invert___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__invert__}, ::Type{T}, ::Type{Integer}, ::Val{1}) where {T<:Integer} =
    @cfunction(pyjulia_implmethod___invert___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### AsPyBufferedIO.write

pyjulia_attrkind(::Val{:write}, ::Type{T}) where {T<:AsPyBufferedIO} =
    :method

pyjulia_attrdef(::Val{:write}, ::Type{T}) where {T<:AsPyBufferedIO} =
    pyjulia_attrdef(Val(:write), T, AsPyBufferedIO, Val(1))

const _pyjulia_implmethod_write_2_1 = function(o, b)
    buf = @safe unsafe_PyBuffer(b, CPyBUF_SIMPLE)
    arr = unsafe_wrap(Array, Ptr{UInt8}(buf.buf), buf.len)
    num = write(o, arr)
    return unsafe_pyint(num)
    @label error
    return PYNULL
end
function pyjulia_implmethod_write_2_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_write_2_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:write}, ::Type{T}, ::Type{AsPyBufferedIO}, ::Val{1}) where {T<:AsPyBufferedIO} = (
    name = "write",
    meth = @cfunction(pyjulia_implmethod_write_2_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AsPyBufferedIO.detach

pyjulia_attrkind(::Val{:detach}, ::Type{T}) where {T<:AsPyBufferedIO} =
    :method

pyjulia_attrdef(::Val{:detach}, ::Type{T}) where {T<:AsPyBufferedIO} =
    pyjulia_attrdef(Val(:detach), T, AsPyBufferedIO, Val(1))

const _pyjulia_implmethod_detach_1_1 = o -> (pyerror_set_IOUnsupportedOperation("detach"); PYNULL)
function pyjulia_implmethod_detach_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_detach_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:detach}, ::Type{T}, ::Type{AsPyBufferedIO}, ::Val{1}) where {T<:AsPyBufferedIO} = (
    name = "detach",
    meth = @cfunction(pyjulia_implmethod_detach_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000004,
)


### AsPyBufferedIO.readinto

pyjulia_attrkind(::Val{:readinto}, ::Type{T}) where {T<:AsPyBufferedIO} =
    :method

pyjulia_attrdef(::Val{:readinto}, ::Type{T}) where {T<:AsPyBufferedIO} =
    pyjulia_attrdef(Val(:readinto), T, AsPyBufferedIO, Val(1))

const _pyjulia_implmethod_readinto_2_1 = function(o, b)
    buf = @safe unsafe_PyBuffer(b, CPyBUF_WRITABLE)
    arr = unsafe_wrap(Array, Ptr{UInt8}(buf.buf), buf.len)
    num = readbytes!(o, arr)
    return unsafe_pyint(num)
    @label error
    return PYNULL
end
function pyjulia_implmethod_readinto_2_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_readinto_2_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:readinto}, ::Type{T}, ::Type{AsPyBufferedIO}, ::Val{1}) where {T<:AsPyBufferedIO} = (
    name = "readinto",
    meth = @cfunction(pyjulia_implmethod_readinto_2_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AsPyBufferedIO.readinto1

pyjulia_attrkind(::Val{:readinto1}, ::Type{T}) where {T<:AsPyBufferedIO} =
    :method

pyjulia_attrdef(::Val{:readinto1}, ::Type{T}) where {T<:AsPyBufferedIO} =
    pyjulia_attrdef(Val(:readinto1), T, AsPyBufferedIO, Val(1))

const _pyjulia_implmethod_readinto1_1_1 = function(o, b)
    buf = @safe unsafe_PyBuffer(b, CPyBUF_WRITABLE)
    arr = unsafe_wrap(Array, Ptr{UInt8}(buf.buf), buf.len)
    num = readbytes!(o, arr)
    return unsafe_pyint(num)
    @label error
    return PYNULL
end
function pyjulia_implmethod_readinto1_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_readinto1_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:readinto1}, ::Type{T}, ::Type{AsPyBufferedIO}, ::Val{1}) where {T<:AsPyBufferedIO} = (
    name = "readinto1",
    meth = @cfunction(pyjulia_implmethod_readinto1_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000008,
)


### AsPyBufferedIO.read1

pyjulia_attrkind(::Val{:read1}, ::Type{T}) where {T<:AsPyBufferedIO} =
    :method

pyjulia_attrdef(::Val{:read1}, ::Type{T}) where {T<:AsPyBufferedIO} =
    pyjulia_attrdef(Val(:read1), T, AsPyBufferedIO, Val(1))

const _pyjulia_implmethod_read1_1_1 = function (o, _a)
    a = @safe @unsafe_pyargparse _a (n::Union{Int,Nothing}=nothing,)
    if a.n===nothing || a.n < 0
        x = read(o)
    else
        x = read(o, a.n)
    end
    return unsafe_pybytes(x)
    @label error
    return PYNULL
end
function pyjulia_implmethod_read1_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_read1_1_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:read1}, ::Type{T}, ::Type{AsPyBufferedIO}, ::Val{1}) where {T<:AsPyBufferedIO} = (
    name = "read1",
    meth = @cfunction(pyjulia_implmethod_read1_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)


### AsPyBufferedIO.read

pyjulia_attrkind(::Val{:read}, ::Type{T}) where {T<:AsPyBufferedIO} =
    :method

pyjulia_attrdef(::Val{:read}, ::Type{T}) where {T<:AsPyBufferedIO} =
    pyjulia_attrdef(Val(:read), T, AsPyBufferedIO, Val(1))

const _pyjulia_implmethod_read_2_1 = function (o, _a)
    n, = @safe @unsafe_pyargparse _a (n::Union{Int,Nothing}=nothing,)
    if n===nothing || n < 0
        x = read(o)
    else
        x = read(o, n)
    end
    return unsafe_pybytes(x)
    @label error
    return PYNULL
end
function pyjulia_implmethod_read_2_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod_read_2_1(x1, x2))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:read}, ::Type{T}, ::Type{AsPyBufferedIO}, ::Val{1}) where {T<:AsPyBufferedIO} = (
    name = "read",
    meth = @cfunction(pyjulia_implmethod_read_2_1, PyPtr, (Ptr{CPyJuliaObject{T}}, PyPtr)),
    flags = 0x0000000000000001,
)


### AnyRational.denominator

pyjulia_attrkind(::Val{:denominator}, ::Type{T}) where {T<:AnyRational} =
    :property

pyjulia_attrdef(::Val{:denominator}, ::Type{T}) where {T<:AnyRational} =
    pyjulia_attrdef(Val(:denominator), T, AnyRational, Val(1))

const _pyjulia_implgetter_denominator_1_1 = o -> unsafe_pyjulia(denominator(o))
function pyjulia_implgetter_denominator_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implgetter_denominator_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:denominator}, ::Type{T}, ::Type{AnyRational}, ::Val{1}) where {T<:AnyRational} = (
    name = "denominator",
    get = @cfunction(pyjulia_implgetter_denominator_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, Ptr{Cvoid})),
)


### AnyRational.numerator

pyjulia_attrkind(::Val{:numerator}, ::Type{T}) where {T<:AnyRational} =
    :property

pyjulia_attrdef(::Val{:numerator}, ::Type{T}) where {T<:AnyRational} =
    pyjulia_attrdef(Val(:numerator), T, AnyRational, Val(1))

const _pyjulia_implgetter_numerator_1_1 = o -> unsafe_pyjulia(numerator(o))
function pyjulia_implgetter_numerator_1_1(y1, y2)
    x1 = pyjulia_argval(y1)
    x2 = pyjulia_argval(y2)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implgetter_numerator_1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:numerator}, ::Type{T}, ::Type{AnyRational}, ::Val{1}) where {T<:AnyRational} = (
    name = "numerator",
    get = @cfunction(pyjulia_implgetter_numerator_1_1, PyPtr, (Ptr{CPyJuliaObject{T}}, Ptr{Cvoid})),
)


### Number.__float__

pyjulia_attrkind(::Val{:__float__}, ::Type{T}) where {T<:Number} =
    (hasmethod(convert, Tuple{Type{Real}, T})) ? :special :
    invoke(pyjulia_attrkind, Tuple{Val{:__float__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__float__), T)

pyjulia_attrdef(::Val{:__float__}, ::Type{T}) where {T<:Number} =
    (hasmethod(convert, Tuple{Type{Real}, T})) ? pyjulia_attrdef(Val(:__float__), T, Number, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__float__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__float__), T)

const _pyjulia_implmethod___float___2_1 = o -> unsafe_pyfloat(convert(Real, o))
function pyjulia_implmethod___float___2_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___float___2_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__float__}, ::Type{T}, ::Type{Number}, ::Val{1}) where {T<:Number} =
    @cfunction(pyjulia_implmethod___float___2_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Number.__bool__

pyjulia_attrkind(::Val{:__bool__}, ::Type{T}) where {T<:Number} =
    (hasmethod(iszero, Tuple{T})) ? :special :
    invoke(pyjulia_attrkind, Tuple{Val{:__bool__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__bool__), T)

pyjulia_attrdef(::Val{:__bool__}, ::Type{T}) where {T<:Number} =
    (hasmethod(iszero, Tuple{T})) ? pyjulia_attrdef(Val(:__bool__), T, Number, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__bool__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__bool__), T)

const _pyjulia_implmethod___bool___1_1 = o -> !iszero(o)
function pyjulia_implmethod___bool___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::Cint = pyjulia_retval(_pyjulia_implmethod___bool___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return (zero(Cint) - one(Cint))
    end
end

pyjulia_attrdef(::Val{:__bool__}, ::Type{T}, ::Type{Number}, ::Val{1}) where {T<:Number} =
    @cfunction(pyjulia_implmethod___bool___1_1, Cint, (Ptr{CPyJuliaObject{T}},))


### Number.__neg__

pyjulia_attrkind(::Val{:__neg__}, ::Type{T}) where {T<:Number} =
    (hasmethod(-, Tuple{T})) ? :special :
    invoke(pyjulia_attrkind, Tuple{Val{:__neg__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__neg__), T)

pyjulia_attrdef(::Val{:__neg__}, ::Type{T}) where {T<:Number} =
    (hasmethod(-, Tuple{T})) ? pyjulia_attrdef(Val(:__neg__), T, Number, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__neg__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__neg__), T)

const _pyjulia_implmethod___neg___1_1 = o -> unsafe_pyjulia(-o)
function pyjulia_implmethod___neg___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___neg___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__neg__}, ::Type{T}, ::Type{Number}, ::Val{1}) where {T<:Number} =
    @cfunction(pyjulia_implmethod___neg___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Number.__pos__

pyjulia_attrkind(::Val{:__pos__}, ::Type{T}) where {T<:Number} =
    (hasmethod(+, Tuple{T})) ? :special :
    invoke(pyjulia_attrkind, Tuple{Val{:__pos__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__pos__), T)

pyjulia_attrdef(::Val{:__pos__}, ::Type{T}) where {T<:Number} =
    (hasmethod(+, Tuple{T})) ? pyjulia_attrdef(Val(:__pos__), T, Number, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__pos__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__pos__), T)

const _pyjulia_implmethod___pos___1_1 = o -> unsafe_pyjulia(+o)
function pyjulia_implmethod___pos___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___pos___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__pos__}, ::Type{T}, ::Type{Number}, ::Val{1}) where {T<:Number} =
    @cfunction(pyjulia_implmethod___pos___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Number.__int__

pyjulia_attrkind(::Val{:__int__}, ::Type{T}) where {T<:Number} =
    (hasmethod(convert, Tuple{Type{Integer}, T})) ? :special :
    invoke(pyjulia_attrkind, Tuple{Val{:__int__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__int__), T)

pyjulia_attrdef(::Val{:__int__}, ::Type{T}) where {T<:Number} =
    (hasmethod(convert, Tuple{Type{Integer}, T})) ? pyjulia_attrdef(Val(:__int__), T, Number, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__int__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__int__), T)

const _pyjulia_implmethod___int___2_1 = o -> unsafe_pyint(convert(Integer, o))
function pyjulia_implmethod___int___2_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___int___2_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__int__}, ::Type{T}, ::Type{Number}, ::Val{1}) where {T<:Number} =
    @cfunction(pyjulia_implmethod___int___2_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


### Number.__abs__

pyjulia_attrkind(::Val{:__abs__}, ::Type{T}) where {T<:Number} =
    (hasmethod(abs, Tuple{T})) ? :special :
    invoke(pyjulia_attrkind, Tuple{Val{:__abs__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__abs__), T)

pyjulia_attrdef(::Val{:__abs__}, ::Type{T}) where {T<:Number} =
    (hasmethod(abs, Tuple{T})) ? pyjulia_attrdef(Val(:__abs__), T, Number, Val(1)) :
    invoke(pyjulia_attrdef, Tuple{Val{:__abs__}, Type{_T}} where {_T<:supertype(Number)}, Val(:__abs__), T)

const _pyjulia_implmethod___abs___1_1 = o -> unsafe_pyjulia(abs(o))
function pyjulia_implmethod___abs___1_1(y1)
    x1 = pyjulia_argval(y1)
    try
        r::PyPtr = pyjulia_retval(_pyjulia_implmethod___abs___1_1(x1))
        return r
    catch err
        perr = unsafe_pyobj(err)
        pyerror_set(pyexc_JuliaException_type(), perr)
        return PyPtr(C_NULL)
    end
end

pyjulia_attrdef(::Val{:__abs__}, ::Type{T}, ::Type{Number}, ::Val{1}) where {T<:Number} =
    @cfunction(pyjulia_implmethod___abs___1_1, PyPtr, (Ptr{CPyJuliaObject{T}},))


